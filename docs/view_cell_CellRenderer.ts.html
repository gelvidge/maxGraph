

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/cell/CellRenderer.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/cell/CellRenderer.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2017, JGraph Ltd
 * Copyright (c) 2006-2017, Gaudenz Alder
 */

import RectangleShape from '../geometry/node/RectangleShape';
import EllipseShape from '../geometry/node/EllipseShape';
import RhombusShape from '../geometry/node/RhombusShape';
import CylinderShape from '../geometry/node/CylinderShape';
import ConnectorShape from '../geometry/edge/ConnectorShape';
import ActorShape from '../geometry/ActorShape';
import TriangleShape from '../geometry/node/TriangleShape';
import HexagonShape from '../geometry/node/HexagonShape';
import CloudShape from '../geometry/node/CloudShape';
import LineShape from '../geometry/edge/LineShape';
import ArrowShape from '../geometry/edge/ArrowShape';
import ArrowConnectorShape from '../geometry/edge/ArrowConnectorShape';
import DoubleEllipseShape from '../geometry/node/DoubleEllipseShape';
import SwimlaneShape from '../geometry/node/SwimlaneShape';
import ImageShape from '../geometry/node/ImageShape';
import LabelShape from '../geometry/node/LabelShape';
import TextShape from '../geometry/node/TextShape';
import {
  ALIGN,
  DEFAULT_FONTFAMILY,
  DEFAULT_FONTSIZE,
  DEFAULT_FONTSTYLE,
  DEFAULT_TEXT_DIRECTION,
  DIALECT,
  NONE,
  SHAPE,
} from '../../util/constants';
import {
  getRotatedPoint,
  mod,
  toRadians,
} from '../../util/mathUtils';
import { convertPoint } from '../../util/styleUtils';
import { 
  equalEntries,
  equalPoints,
} from '../../util/arrayUtils';
import Rectangle from '../geometry/Rectangle';
import StencilShapeRegistry from '../geometry/node/StencilShapeRegistry';
import InternalEvent from '../event/InternalEvent';
import Client from '../../Client';
import InternalMouseEvent from '../event/InternalMouseEvent';
import Dictionary from '../../util/Dictionary';
import EventObject from '../event/EventObject';
import Point from '../geometry/Point';
import Shape from '../geometry/Shape';
import CellState from './CellState';
import Cell from './Cell';
import CellOverlay from './CellOverlay';
import { getClientX, getClientY, getSource } from '../../util/eventUtils';
import { isNode } from '../../util/domUtils';
import { CellStateStyles } from '../../types';
import CellArray from './CellArray';
import SelectionCellsHandler from '../handler/SelectionCellsHandler';
import { Graph } from '../Graph';

/**
 * Renders cells into a document object model. The &lt;defaultShapes> is a global
 * map of shapename, constructor pairs that is used in all instances. You can
 * get a list of all available shape names using the following code.
 *
 * In general the cell renderer is in charge of creating, redrawing and
 * destroying the shape and label associated with a cell state, as well as
 * some other graphical objects, namely controls and overlays. The shape
 * hieararchy in the display (ie. the hierarchy in which the DOM nodes
 * appear in the document) does not reflect the cell hierarchy. The shapes
 * are a (flat) sequence of shapes and labels inside the draw pane of the
 * graph view, with some exceptions, namely the HTML labels being placed
 * directly inside the graph container for certain browsers.
 *
 * ```javascript
 * MaxLog.show();
 * for (var i in mxCellRenderer.defaultShapes)
 * {
 *   MaxLog.debug(i);
 * }
 * ```
 *
 * Constructor: mxCellRenderer
 *
 * Constructs a new cell renderer with the following built-in shapes:
 * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,
 * swimlane, connector, actor and cloud.
 */
class CellRenderer {
  /**
   * Static array that contains the globally registered shapes which are
   * known to all instances of this class. For adding new shapes you should
   * use the static &lt;mxCellRenderer.registerShape> function.
   */
  static defaultShapes: { [key: string]: typeof Shape } = {};

  /**
   * Defines the default shape for edges. Default is &lt;mxConnector>.
   */
  // @ts-expect-error The constructors for Shape and Connector are different.
  defaultEdgeShape: typeof Shape = ConnectorShape;

  /**
   * Defines the default shape for vertices. Default is &lt;mxRectangleShape>.
   */
  defaultVertexShape: typeof RectangleShape = RectangleShape;

  /**
   * Defines the default shape for labels. Default is &lt;mxText>.
   */
  defaultTextShape: typeof TextShape = TextShape;

  /**
   * Specifies if the folding icon should ignore the horizontal
   * orientation of a swimlane. Default is true.
   */
  legacyControlPosition = true;

  /**
   * Specifies if spacing and label position should be ignored if overflow is
   * fill or width. Default is true for backwards compatiblity.
   */
  legacySpacing = true;

  /**
   * Anti-aliasing option for new shapes. Default is true.
   */
  antiAlias = true;

  /**
   * Minimum stroke width for SVG output.
   */
  minSvgStrokeWidth = 1;

  /**
   * Specifies if the enabled state of the graph should be ignored in the control
   * click handler (to allow folding in disabled graphs). Default is false.
   */
  forceControlClickHandler = false;

  /**
   * Registers the given constructor under the specified key in this instance of the renderer.
   * @example
   * ```
   * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);
   * ```
   *
   * @param key the shape name.
   * @param shape constructor of the {@link Shape} subclass.
   */
  static registerShape(key: string, shape: typeof Shape) {
    CellRenderer.defaultShapes[key] = shape;
  }

  /**
   * Initializes the shape in the given state by calling its init method with
   * the correct container after configuring it using &lt;configureShape>.
   *
   * @param state &lt;CellState> for which the shape should be initialized.
   */
  initializeShape(state: CellState) {
    if (state.shape) {
      state.shape.dialect = (&lt;Graph>state.view.graph).dialect;
      this.configureShape(state);
      state.shape.init(state.view.getDrawPane());
    }
  }

  /**
   * Creates and returns the shape for the given cell state.
   *
   * @param state &lt;CellState> for which the shape should be created.
   */
  createShape(state: CellState) {
    let shape = null;

    // Checks if there is a stencil for the name and creates
    // a shape instance for the stencil if one exists
    const stencil = StencilShapeRegistry.getStencil(&lt;string>state.style.shape);

    if (stencil) {
      shape = new Shape(stencil);
    } else {
      const ctor = this.getShapeConstructor(state);
      shape = new ctor();
    }

    return shape;
  }

  /**
   * Creates the indicator shape for the given cell state.
   *
   * @param state &lt;CellState> for which the indicator shape should be created.
   */
  createIndicatorShape(state: CellState) {
    if (state.shape) {
      state.shape.indicatorShape = this.getShape(state.getIndicatorShape() || null);
    }
  }

  /**
   * Returns the shape for the given name from &lt;defaultShapes>.
   */
  getShape(name: string | null) {
    return name ? CellRenderer.defaultShapes[name] : null;
  }

  /**
   * Returns the constructor to be used for creating the shape.
   */
  getShapeConstructor(state: CellState) {
    let ctor = this.getShape(state.style.shape || null);

    if (!ctor) {
      // @ts-expect-error The various Shape constructors are not compatible.
      ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;
    }

    return ctor as typeof Shape;
  }

  /**
   * Configures the shape for the given cell state.
   *
   * @param state &lt;CellState> for which the shape should be configured.
   */
  configureShape(state: CellState) {
    const shape = state.shape;

    if (shape) {
      shape.apply(state);
      shape.imageSrc = state.getImageSrc() || null;
      shape.indicatorColor = state.getIndicatorColor() || NONE;
      shape.indicatorStrokeColor = state.style.indicatorStrokeColor || NONE;
      shape.indicatorGradientColor = state.getIndicatorGradientColor() || NONE;
      if (state.style.indicatorDirection) {
        shape.indicatorDirection = state.style.indicatorDirection;
      }
      shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;
      this.postConfigureShape(state);
    }
  }

  /**
   * Replaces any reserved words used for attributes, eg. inherit,
   * indicated or swimlane for colors in the shape for the given state.
   * This implementation resolves these keywords on the fill, stroke
   * and gradient color keys.
   */
  postConfigureShape(state: CellState) {
    if (state.shape) {
      this.resolveColor(state, 'indicatorGradientColor', 'gradientColor');
      this.resolveColor(state, 'indicatorColor', 'fillColor');
      this.resolveColor(state, 'gradient', 'gradientColor');
      this.resolveColor(state, 'stroke', 'strokeColor');
      this.resolveColor(state, 'fill', 'fillColor');
    }
  }

  /**
   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets
   * the respective color on the shape.
   */
  checkPlaceholderStyles(state: CellState) {
    // LATER: Check if the color has actually changed
    if (state.style) {
      const values = ['inherit', 'swimlane', 'indicated'];
      const styles: (keyof CellStateStyles)[] = [
        'fillColor',
        'strokeColor',
        'gradientColor',
        'fontColor',
      ];

      for (let i = 0; i &lt; styles.length; i += 1) {
        if (values.indexOf(state.style[styles[i]] as string) >= 0) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets
   * the respective color on the shape.
   */
  resolveColor(state: CellState, field: string, key: string) {
    const shape: Shape | null = key === 'fontColor' ? state.text : state.shape;

    if (shape) {
      const graph = &lt;Graph>state.view.graph;

      // @ts-ignore
      const value = shape[field];
      let referenced = null;

      if (value === 'inherit') {
        referenced = state.cell.getParent();
      } else if (value === 'swimlane') {
        // @ts-ignore
        shape[field] =
          key === 'strokeColor' || key === 'fontColor' ? '#000000' : '#ffffff';

        if (state.cell.getTerminal(false)) {
          referenced = state.cell.getTerminal(false);
        } else {
          referenced = state.cell;
        }

        referenced = graph.getSwimlane(&lt;Cell>referenced);
        key = graph.swimlaneIndicatorColorAttribute;
      } else if (value === 'indicated' &amp;&amp; state.shape) {
        // @ts-ignore
        shape[field] = state.shape.indicatorColor;
      } else if (key !== 'fillColor' &amp;&amp; value === 'fillColor' &amp;&amp; state.shape) {
        // @ts-ignore
        shape[field] = state.style.fillColor;
      } else if (key !== 'strokeColor' &amp;&amp; value === 'strokeColor' &amp;&amp; state.shape) {
        // @ts-ignore
        shape[field] = state.style.strokeColor;
      }

      if (referenced) {
        const rstate = graph.getView().getState(referenced);
        // @ts-ignore
        shape[field] = null;

        if (rstate) {
          const rshape = key === 'fontColor' ? rstate.text : rstate.shape;

          if (rshape &amp;&amp; field !== 'indicatorColor') {
            // @ts-ignore
            shape[field] = rshape[field];
          } else {
            // @ts-ignore
            shape[field] = rstate.style[key];
          }
        }
      }
    }
  }

  /**
   * Returns the value to be used for the label.
   *
   * @param state &lt;CellState> for which the label should be created.
   */
  getLabelValue(state: CellState) {
    const graph = &lt;Graph>state.view.graph;
    return graph.getLabel(state.cell);
  }

  /**
   * Creates the label for the given cell state.
   *
   * @param state &lt;CellState> for which the label should be created.
   */
  createLabel(state: CellState, value: string) {
    const graph = &lt;Graph>state.view.graph;

    if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {
      // Avoids using DOM node for empty labels
      const isForceHtml = graph.isHtmlLabel(state.cell) || isNode(value);

      state.text = new this.defaultTextShape(
        value,
        new Rectangle(),
        state.style.align ?? ALIGN.CENTER,
        state.getVerticalAlign(),
        state.style.fontColor,
        state.style.fontFamily,
        state.style.fontSize,
        state.style.fontStyle,
        state.style.spacing,
        state.style.spacingTop,
        state.style.spacingRight,
        state.style.spacingBottom,
        state.style.spacingLeft,
        state.style.horizontal,
        state.style.labelBackgroundColor,
        state.style.labelBorderColor,
        graph.isWrapping(state.cell) &amp;&amp; graph.isHtmlLabel(state.cell),
        graph.isLabelClipped(state.cell),
        state.style.overflow,
        state.style.labelPadding,
        state.style.textDirection ?? DEFAULT_TEXT_DIRECTION
      );
      state.text.opacity = state.style.textOpacity ?? 100;
      state.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
      state.text.style = state.style;
      state.text.state = state;
      this.initializeLabel(state, state.text);

      // Workaround for touch devices routing all events for a mouse gesture
      // (down, move, up) via the initial DOM node. IE additionally redirects
      // the event via the initial DOM node but the event source is the node
      // under the mouse, so we need to check if this is the case and force
      // getCellAt for the subsequent mouseMoves and the final mouseUp.
      let forceGetCell = false;

      const getState = (evt: MouseEvent) => {
        let result: CellState | null = state;

        if (Client.IS_TOUCH || forceGetCell) {
          const x = getClientX(evt);
          const y = getClientY(evt);

          // Dispatches the drop event to the graph which
          // consumes and executes the source function
          const pt = convertPoint(graph.container, x, y);
          result = graph.view.getState(graph.getCellAt(pt.x, pt.y) as Cell);
        }
        return result;
      };

      // TODO: Add handling for special touch device gestures
      InternalEvent.addGestureListeners(
        state.text.node,
        (evt: MouseEvent) => {
          if (this.isLabelEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_DOWN,
              new InternalMouseEvent(evt, state)
            );

            const source = getSource(evt);

            forceGetCell =
              // @ts-ignore nodeName should exist.
              graph.dialect !== DIALECT.SVG &amp;&amp; source.nodeName === 'IMG';
          }
        },
        (evt: MouseEvent) => {
          if (this.isLabelEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_MOVE,
              new InternalMouseEvent(evt, getState(evt))
            );
          }
        },
        (evt: MouseEvent) => {
          if (this.isLabelEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_UP,
              new InternalMouseEvent(evt, getState(evt))
            );
            forceGetCell = false;
          }
        }
      );

      // Uses double click timeout in mxGraph for quirks mode
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent.addListener(state.text.node, 'dblclick', (evt: MouseEvent) => {
          if (this.isLabelEvent(state, evt)) {
            graph.dblClick(evt, state.cell);
            InternalEvent.consume(evt);
          }
        });
      }
    }
  }

  /**
   * Initiailzes the label with a suitable container.
   *
   * @param state &lt;CellState> whose label should be initialized.
   */
  initializeLabel(state: CellState, shape: Shape): void {
    if (Client.IS_SVG &amp;&amp; Client.NO_FO &amp;&amp; shape.dialect !== DIALECT.SVG) {
      const graph = &lt;Graph>state.view.graph;
      shape.init(graph.container);
    } else {
      shape.init(state.view.getDrawPane());
    }
  }

  /**
   * Creates the actual shape for showing the overlay for the given cell state.
   *
   * @param state &lt;CellState> for which the overlay should be created.
   */
  createCellOverlays(state: CellState) {
    const graph = &lt;Graph>state.view.graph;
    const overlays = graph.getCellOverlays(state.cell);
    const dict = new Dictionary&lt;CellOverlay, Shape>();

    for (let i = 0; i &lt; overlays.length; i += 1) {
      const shape = state.overlays.remove(overlays[i]);

      if (!shape) {
        const tmp = new ImageShape(new Rectangle(), overlays[i].image.src);
        tmp.dialect = graph.dialect;
        tmp.preserveImageAspect = false;
        tmp.overlay = overlays[i];
        this.initializeOverlay(state, tmp);
        this.installCellOverlayListeners(state, overlays[i], tmp);

        if (overlays[i].cursor) {
          tmp.node.style.cursor = overlays[i].cursor;
        }

        dict.put(overlays[i], tmp);
      } else {
        dict.put(overlays[i], shape);
      }
    }

    // Removes unused
    state.overlays.visit((id: any, shape: { destroy: () => void }) => {
      shape.destroy();
    });

    state.overlays = dict;
  }

  /**
   * Initializes the given overlay.
   *
   * @param state &lt;CellState> for which the overlay should be created.
   * @param overlay &lt;mxImageShape> that represents the overlay.
   */
  initializeOverlay(state: CellState, overlay: ImageShape) {
    overlay.init(state.view.getOverlayPane());
  }

  /**
   * Installs the listeners for the given &lt;CellState>, &lt;CellOverlay> and
   * &lt;mxShape> that represents the overlay.
   */
  installCellOverlayListeners(state: CellState, overlay: CellOverlay, shape: Shape) {
    const graph = &lt;Graph>state.view.graph;

    InternalEvent.addListener(shape.node, 'click', (evt: Event) => {
      if (graph.isEditing()) {
        graph.stopEditing(!graph.isInvokesStopCellEditing());
      }

      overlay.fireEvent(
        new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell })
      );
    });

    InternalEvent.addGestureListeners(
      shape.node,
      (evt: Event) => {
        InternalEvent.consume(evt);
      },
      (evt: Event) => {
        graph.fireMouseEvent(
          InternalEvent.MOUSE_MOVE,
          new InternalMouseEvent(evt as MouseEvent, state)
        );
      }
    );

    if (Client.IS_TOUCH) {
      InternalEvent.addListener(shape.node, 'touchend', (evt: Event) => {
        overlay.fireEvent(
          new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell })
        );
      });
    }
  }

  /**
   * Creates the control for the given cell state.
   *
   * @param state &lt;CellState> for which the control should be created.
   */
  createControl(state: CellState) {
    const graph = &lt;Graph>state.view.graph;
    const image = graph.getFoldingImage(state);

    if (graph.isFoldingEnabled() &amp;&amp; image) {
      if (!state.control) {
        const b = new Rectangle(0, 0, image.width, image.height);
        state.control = new ImageShape(b, image.src);
        state.control.preserveImageAspect = false;
        state.control.dialect = graph.dialect;

        this.initControl(
          state,
          state.control,
          true,
          this.createControlClickHandler(state)
        );
      }
    } else if (state.control) {
      state.control.destroy();
      state.control = null;
    }
  }

  /**
   * Hook for creating the click handler for the folding icon.
   *
   * @param state &lt;CellState> whose control click handler should be returned.
   */
  createControlClickHandler(state: CellState) {
    const graph = &lt;Graph>state.view.graph;

    return (evt: Event) => {
      if (this.forceControlClickHandler || graph.isEnabled()) {
        const collapse = !state.cell.isCollapsed();
        graph.foldCells(collapse, false, new CellArray(state.cell), false, evt);
        InternalEvent.consume(evt);
      }
    };
  }

  /**
   * Initializes the given control and returns the corresponding DOM node.
   *
   * @param state &lt;CellState> for which the control should be initialized.
   * @param control &lt;mxShape> to be initialized.
   * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.
   * @param clickHandler Optional function to implement clicks on the control.
   */
  initControl(
    state: CellState,
    control: Shape,
    handleEvents: boolean,
    clickHandler: EventListener
  ): Element {
    const graph = &lt;Graph>state.view.graph;

    // In the special case where the label is in HTML and the display is SVG the image
    // should go into the graph container directly in order to be clickable. Otherwise
    // it is obscured by the HTML label that overlaps the cell.
    const isForceHtml =
      graph.isHtmlLabel(state.cell) &amp;&amp; Client.NO_FO &amp;&amp; graph.dialect === DIALECT.SVG;

    if (isForceHtml) {
      control.dialect = DIALECT.PREFERHTML;
      control.init(graph.container);
      control.node.style.zIndex = String(1);
    } else {
      control.init(state.view.getOverlayPane());
    }

    const node = control.node;

    // Workaround for missing click event on iOS is to check tolerance below
    if (clickHandler &amp;&amp; !Client.IS_IOS) {
      if (graph.isEnabled()) {
        node.style.cursor = 'pointer';
      }

      InternalEvent.addListener(node, 'click', clickHandler);
    }

    if (handleEvents) {
      let first: Point | null = null;

      InternalEvent.addGestureListeners(
        node,
        (evt: MouseEvent) => {
          first = new Point(getClientX(evt), getClientY(evt));
          graph.fireMouseEvent(
            InternalEvent.MOUSE_DOWN,
            new InternalMouseEvent(evt, state)
          );
          InternalEvent.consume(evt);
        },
        (evt: MouseEvent) => {
          graph.fireMouseEvent(
            InternalEvent.MOUSE_MOVE,
            new InternalMouseEvent(evt, state)
          );
        },
        (evt: MouseEvent) => {
          graph.fireMouseEvent(
            InternalEvent.MOUSE_UP,
            new InternalMouseEvent(evt, state)
          );
          InternalEvent.consume(evt);
        }
      );

      // Uses capture phase for event interception to stop bubble phase
      if (clickHandler &amp;&amp; Client.IS_IOS) {
        node.addEventListener(
          'touchend',
          (evt: Event) => {
            if (first) {
              const tol = graph.getEventTolerance();

              if (
                Math.abs(first.x - getClientX(evt as MouseEvent)) &lt; tol &amp;&amp;
                Math.abs(first.y - getClientY(evt as MouseEvent)) &lt; tol
              ) {
                clickHandler.call(clickHandler, evt);
                InternalEvent.consume(evt);
              }
            }
          },
          true
        );
      }
    }

    return node;
  }

  /**
   * Returns true if the event is for the shape of the given state. This
   * implementation always returns true.
   *
   * @param state &lt;CellState> whose shape fired the event.
   * @param evt Mouse event which was fired.
   */
  isShapeEvent(state: CellState, evt: MouseEvent) {
    return true;
  }

  /**
   * Returns true if the event is for the label of the given state. This
   * implementation always returns true.
   *
   * @param state &lt;CellState> whose label fired the event.
   * @param evt Mouse event which was fired.
   */
  isLabelEvent(state: CellState, evt: MouseEvent) {
    return true;
  }

  /**
   * Installs the event listeners for the given cell state.
   *
   * @param state &lt;CellState> for which the event listeners should be isntalled.
   */
  installListeners(state: CellState) {
    const graph = &lt;Graph>state.view.graph;

    // Workaround for touch devices routing all events for a mouse
    // gesture (down, move, up) via the initial DOM node. Same for
    // HTML images in all IE versions (VML images are working).
    const getState = (evt: MouseEvent) => {
      let result: CellState | null = state;
      const source = getSource(evt);

      if (
        (source &amp;&amp;
          graph.dialect !== DIALECT.SVG &amp;&amp;
          // @ts-ignore nodeName should exist
          source.nodeName === 'IMG') ||
        Client.IS_TOUCH
      ) {
        const x = getClientX(evt);
        const y = getClientY(evt);

        // Dispatches the drop event to the graph which
        // consumes and executes the source function
        const pt = convertPoint(graph.container, x, y);
        const cell = graph.getCellAt(pt.x, pt.y);

        result = cell ? graph.view.getState(cell) : null;
      }

      return result;
    };

    if (state.shape) {
      InternalEvent.addGestureListeners(
        state.shape.node,
        (evt: MouseEvent) => {
          if (this.isShapeEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_DOWN,
              new InternalMouseEvent(evt, state)
            );
          }
        },
        (evt: MouseEvent) => {
          if (this.isShapeEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_MOVE,
              new InternalMouseEvent(evt, getState(evt))
            );
          }
        },
        (evt: MouseEvent) => {
          if (this.isShapeEvent(state, evt)) {
            graph.fireMouseEvent(
              InternalEvent.MOUSE_UP,
              new InternalMouseEvent(evt, getState(evt))
            );
          }
        }
      );

      // Uses double click timeout in mxGraph for quirks mode
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent.addListener(state.shape.node, 'dblclick', (evt: MouseEvent) => {
          if (this.isShapeEvent(state, evt)) {
            graph.dblClick(evt, state.cell);
            InternalEvent.consume(evt);
          }
        });
      }
    }
  }

  /**
   * Redraws the label for the given cell state.
   *
   * @param state &lt;CellState> whose label should be redrawn.
   */
  redrawLabel(state: CellState, forced: boolean) {
    const graph = &lt;Graph>state.view.graph;
    const value = this.getLabelValue(state);
    const wrapping = graph.isWrapping(state.cell);
    const clipping = graph.isLabelClipped(state.cell);
    const isForceHtml =
    graph.isHtmlLabel(state.cell) || (value &amp;&amp; isNode(value));
    const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
    const overflow = state.style.overflow ?? 'visible';

    if (
      state.text &amp;&amp;
      (state.text.wrap !== wrapping ||
        state.text.clipped !== clipping ||
        state.text.overflow !== overflow ||
        state.text.dialect !== dialect)
    ) {
      state.text.destroy();
      state.text = null;
    }

    if (state.text == null &amp;&amp; value != null &amp;&amp; (isNode(value) || value.length > 0)) {
      this.createLabel(state, value);
    } else if (state.text != null &amp;&amp; (value == null || value.length == 0)) {
      state.text.destroy();
      state.text = null;
    }

    if (state.text != null) {
      // Forced is true if the style has changed, so to get the updated
      // result in getLabelBounds we apply the new style to the shape
      if (forced) {
        // Checks if a full repaint is needed
        if (state.text.lastValue != null &amp;&amp; this.isTextShapeInvalid(state, state.text)) {
          // Forces a full repaint
          state.text.lastValue = null;
        }

        state.text.resetStyles();
        state.text.apply(state);

        // Special case where value is obtained via hook in graph
        state.text.valign = state.getVerticalAlign();
      }

      const bounds = this.getLabelBounds(state);
      const nextScale = this.getTextScale(state);
      this.resolveColor(state, 'color', 'fontColor');

      if (
        forced ||
        state.text.value !== value ||
        state.text.wrap !== wrapping ||
        state.text.overflow !== overflow ||
        state.text.clipped !== clipping ||
        state.text.scale !== nextScale ||
        state.text.dialect !== dialect ||
        state.text.bounds == null ||
        !state.text.bounds.equals(bounds)
      ) {
        state.text.dialect = dialect;
        state.text.value = value as string;
        state.text.bounds = bounds;
        state.text.scale = nextScale;
        state.text.wrap = wrapping;
        state.text.clipped = clipping;
        state.text.overflow = overflow;

        // Preserves visible state
        // @ts-ignore
        const vis = state.text.node.style.visibility;
        this.redrawLabelShape(state.text);
        // @ts-ignore
        state.text.node.style.visibility = vis;
      }
    }
  }

  /**
   * Returns true if the style for the text shape has changed.
   *
   * @param state &lt;CellState> whose label should be checked.
   * @param shape &lt;mxText> shape to be checked.
   */
  isTextShapeInvalid(state: CellState, shape: TextShape): boolean {
    function check(property: string, stylename: string, defaultValue: any) {
      let result = false;

      // Workaround for spacing added to directional spacing
      if (
        stylename === 'spacingTop' ||
        stylename === 'spacingRight' ||
        stylename === 'spacingBottom' ||
        stylename === 'spacingLeft'
      ) {
        result =
          // @ts-ignore
          parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !==
          (state.style[stylename] || defaultValue);
      } else {
        // @ts-ignore
        result = shape[property] !== (state.style[stylename] || defaultValue);
      }

      return result;
    }

    return (
      check('fontStyle', 'fontStyle', DEFAULT_FONTSTYLE) ||
      check('family', 'fontFamily', DEFAULT_FONTFAMILY) ||
      check('size', 'fontSize', DEFAULT_FONTSIZE) ||
      check('color', 'fontColor', 'black') ||
      check('align', 'align', '') ||
      check('valign', 'verticalAlign', '') ||
      check('spacing', 'spacing', 2) ||
      check('spacingTop', 'spacingTop', 0) ||
      check('spacingRight', 'spacingRight', 0) ||
      check('spacingBottom', 'spacingBottom', 0) ||
      check('spacingLeft', 'spacingLeft', 0) ||
      check('horizontal', 'horizontal', true) ||
      check('background', 'labelBackgroundColor', null) ||
      check('border', 'labelBorderColor', null) ||
      check('opacity', 'textOpacity', 100) ||
      check('textDirection', 'textDirection', DEFAULT_TEXT_DIRECTION)
    );
  }

  /**
   * Called to invoked redraw on the given text shape.
   *
   * @param shape &lt;mxText> shape to be redrawn.
   */
  redrawLabelShape(shape: TextShape): void {
    shape.redraw();
  }

  /**
   * Returns the scaling used for the label of the given state
   *
   * @param state &lt;CellState> whose label scale should be returned.
   */
  getTextScale(state: CellState): number {
    return state.view.scale;
  }

  /**
   * Returns the bounds to be used to draw the label of the given state.
   *
   * @param state &lt;CellState> whose label bounds should be returned.
   */
  getLabelBounds(state: CellState): Rectangle {
    const { scale } = state.view;
    const isEdge = state.cell.isEdge();
    let bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y);

    if (isEdge) {
      // @ts-ignore
      const spacing = state.text.getSpacing();
      bounds.x += spacing.x * scale;
      bounds.y += spacing.y * scale;

      const geo = state.cell.getGeometry();

      if (geo != null) {
        bounds.width = Math.max(0, geo.width * scale);
        bounds.height = Math.max(0, geo.height * scale);
      }
    } else {
      // Inverts label position
      // @ts-ignore
      if (state.text.isPaintBoundsInverted()) {
        const tmp = bounds.x;
        bounds.x = bounds.y;
        bounds.y = tmp;
      }

      bounds.x += state.x;
      bounds.y += state.y;

      // Minimum of 1 fixes alignment bug in HTML labels
      bounds.width = Math.max(1, state.width);
      bounds.height = Math.max(1, state.height);
    }

    // @ts-ignore
    if (state.text.isPaintBoundsInverted()) {
      // Rotates around center of state
      const t = (state.width - state.height) / 2;
      bounds.x += t;
      bounds.y -= t;
      const tmp = bounds.width;
      bounds.width = bounds.height;
      bounds.height = tmp;
    }

    // Shape can modify its label bounds
    if (state.shape != null) {
      const hpos = state.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;

      if (hpos === ALIGN.CENTER &amp;&amp; vpos === ALIGN.MIDDLE) {
        bounds = state.shape.getLabelBounds(bounds);
      }
    }

    // Label width style overrides actual label width
    const lw = state.style.labelWidth ?? null;

    if (lw != null) {
      bounds.width = lw * scale;
    }
    if (!isEdge) {
      this.rotateLabelBounds(state, bounds);
    }

    return bounds;
  }

  /**
   * Adds the shape rotation to the given label bounds and
   * applies the alignment and offsets.
   *
   * @param state &lt;CellState> whose label bounds should be rotated.
   * @param bounds &lt;mxRectangle> the rectangle to be rotated.
   */
  rotateLabelBounds(state: CellState, bounds: Rectangle): void {
    bounds.y -= state.text!.margin!.y * bounds.height;
    bounds.x -= state.text!.margin!.x * bounds.width;

    if (
      !this.legacySpacing ||
      (state.style.overflow !== 'fill' &amp;&amp; state.style.overflow !== 'width')
    ) {
      const s = state.view.scale;
      const spacing = state.text!.getSpacing();
      bounds.x += spacing.x * s;
      bounds.y += spacing.y * s;

      const hpos = state.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;
      const lw = state.style.labelWidth ?? null;

      bounds.width = Math.max(
        0,
        bounds.width -
          (hpos === ALIGN.CENTER &amp;&amp; lw == null
            ? // @ts-ignore
              state.text.spacingLeft * s + state.text.spacingRight * s
            : 0)
      );
      bounds.height = Math.max(
        0,
        bounds.height -
          (vpos === ALIGN.MIDDLE
            ? // @ts-ignore
              state.text.spacingTop * s + state.text.spacingBottom * s
            : 0)
      );
    }

    // @ts-ignore
    const theta = state.text.getTextRotation();

    // Only needed if rotated around another center
    if (
      theta !== 0 &amp;&amp;
      state != null &amp;&amp;
      // @ts-ignore
      state.cell.isVertex()
    ) {
      const cx = state.getCenterX();
      const cy = state.getCenterY();

      if (bounds.x !== cx || bounds.y !== cy) {
        const rad = theta * (Math.PI / 180);
        const pt = getRotatedPoint(
          new Point(bounds.x, bounds.y),
          Math.cos(rad),
          Math.sin(rad),
          new Point(cx, cy)
        );

        bounds.x = pt.x;
        bounds.y = pt.y;
      }
    }
  }

  /**
   * Redraws the overlays for the given cell state.
   *
   * @param state &lt;CellState> whose overlays should be redrawn.
   */
  redrawCellOverlays(state: CellState, forced: boolean = false): void {
    this.createCellOverlays(state);

    if (state.overlays != null) {
      const rot = mod(state.style.rotation ?? 0, 90);
      const rad = toRadians(rot);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);

      state.overlays.visit((id: string, shape: Shape) => {
        // @ts-ignore
        const bounds = shape.overlay.getBounds(state);

        if (!state.cell.isEdge()) {
          if (state.shape != null &amp;&amp; rot !== 0) {
            let cx = bounds.getCenterX();
            let cy = bounds.getCenterY();

            const point = getRotatedPoint(
              new Point(cx, cy),
              cos,
              sin,
              new Point(state.getCenterX(), state.getCenterY())
            );

            cx = point.x;
            cy = point.y;
            bounds.x = Math.round(cx - bounds.width / 2);
            bounds.y = Math.round(cy - bounds.height / 2);
          }
        }

        if (
          forced ||
          shape.bounds == null ||
          shape.scale !== state.view.scale ||
          !shape.bounds.equals(bounds)
        ) {
          shape.bounds = bounds;
          shape.scale = state.view.scale;
          shape.redraw();
        }
      });
    }
  }

  /**
   * Redraws the control for the given cell state.
   *
   * @param state &lt;CellState> whose control should be redrawn.
   */
  redrawControl(state: CellState, forced: boolean = false): void {
    const image = (&lt;Graph>state.view.graph).getFoldingImage(state);

    if (state.control != null &amp;&amp; image != null) {
      const bounds = this.getControlBounds(state, image.width, image.height);

      const r = this.legacyControlPosition
        ? state.style.rotation ?? 0
        : state.shape!.getTextRotation();
      const s = state.view.scale;

      if (
        forced ||
        state.control.scale !== s ||
        !state.control.bounds!.equals(bounds) ||
        state.control.rotation !== r
      ) {
        state.control.rotation = r;
        state.control.bounds = bounds;
        state.control.scale = s;

        state.control.redraw();
      }
    }
  }

  /**
   * Returns the bounds to be used to draw the control (folding icon) of the
   * given state.
   */
  getControlBounds(state: CellState, w: number, h: number): Rectangle | null {
    if (state.control != null) {
      const s = state.view.scale;
      let cx = state.getCenterX();
      let cy = state.getCenterY();

      if (!state.cell.isEdge()) {
        cx = state.x + w * s;
        cy = state.y + h * s;

        if (state.shape != null) {
          // TODO: Factor out common code
          let rot = state.shape.getShapeRotation();

          if (this.legacyControlPosition) {
            rot = state.style.rotation ?? 0;
          } else if (state.shape.isPaintBoundsInverted()) {
            const t = (state.width - state.height) / 2;
            cx += t;
            cy -= t;
          }

          if (rot !== 0) {
            const rad = toRadians(rot);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);

            const point = getRotatedPoint(
              new Point(cx, cy),
              cos,
              sin,
              new Point(state.getCenterX(), state.getCenterY())
            );
            cx = point.x;
            cy = point.y;
          }
        }
      }

      return state.cell.isEdge()
        ? new Rectangle(
            Math.round(cx - (w / 2) * s),
            Math.round(cy - (h / 2) * s),
            Math.round(w * s),
            Math.round(h * s)
          )
        : new Rectangle(
            Math.round(cx - (w / 2) * s),
            Math.round(cy - (h / 2) * s),
            Math.round(w * s),
            Math.round(h * s)
          );
    }

    return null;
  }

  /**
   * Inserts the given array of &lt;mxShapes> after the given nodes in the DOM.
   *
   * @param shapes Array of &lt;mxShapes> to be inserted.
   * @param node Node in &lt;drawPane> after which the shapes should be inserted.
   * @param htmlNode Node in the graph container after which the shapes should be inserted that
   * will not go into the &lt;drawPane> (eg. HTML labels without foreignObjects).
   */
  insertStateAfter(
    state: CellState,
    node: HTMLElement | SVGElement | null,
    htmlNode: HTMLElement | SVGElement | null
  ) {
    const graph = &lt;Graph>state.view.graph;
    const shapes = this.getShapesForState(state);

    for (let i = 0; i &lt; shapes.length; i += 1) {
      // @ts-ignore
      if (shapes[i] != null &amp;&amp; shapes[i].node != null) {
        const html =
          // @ts-ignore
          shapes[i].node.parentNode !== state.view.getDrawPane() &amp;&amp;
          // @ts-ignore
          shapes[i].node.parentNode !== state.view.getOverlayPane();
        const temp = html ? htmlNode : node;

        // @ts-ignore
        if (temp != null &amp;&amp; temp.nextSibling !== shapes[i].node) {
          if (temp.nextSibling == null) {
            // @ts-ignore
            temp.parentNode.appendChild(shapes[i].node);
          } else {
            // @ts-ignore
            temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);
          }
        } else if (temp == null) {
          // Special case: First HTML node should be first sibling after canvas
          // @ts-ignore
          const shapeNode: HTMLElement = &lt;HTMLElement>shapes[i].node;

          if (shapeNode.parentNode === graph.container) {
            let { canvas } = state.view;

            while (canvas != null &amp;&amp; canvas.parentNode !== graph.container) {
              // @ts-ignore
              canvas = canvas.parentNode;
            }

            if (canvas != null &amp;&amp; canvas.nextSibling != null) {
              if (canvas.nextSibling !== shapeNode) {
                // @ts-ignore
                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);
              }
            } else {
              // @ts-ignore
              shapeNode.parentNode.appendChild(shapeNode);
            }
          } else if (
            shapeNode.parentNode != null &amp;&amp;
            shapeNode.parentNode.firstChild != null &amp;&amp;
            shapeNode.parentNode.firstChild != shapeNode
          ) {
            // Inserts the node as the first child of the parent to implement the order
            shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);
          }
        }

        if (html) {
          // @ts-ignore
          htmlNode = shapes[i].node;
        } else {
          // @ts-ignore
          node = shapes[i].node;
        }
      }
    }

    return [node, htmlNode];
  }

  /**
   * Returns the &lt;mxShapes> for the given cell state in the order in which they should
   * appear in the DOM.
   *
   * @param state &lt;CellState> whose shapes should be returned.
   */
  getShapesForState(state: CellState): [Shape | null, TextShape | null, Shape | null] {
    return [state.shape, state.text, state.control];
  }

  /**
   * Updates the bounds or points and scale of the shapes for the given cell
   * state. This is called in mxGraphView.validatePoints as the last step of
   * updating all cells.
   *
   * @param state &lt;CellState> for which the shapes should be updated.
   * @param force Optional boolean that specifies if the cell should be reconfiured
   * and redrawn without any additional checks.
   * @param rendering Optional boolean that specifies if the cell should actually
   * be drawn into the DOM. If this is false then redraw and/or reconfigure
   * will not be called on the shape.
   */
  redraw(state: CellState, force: boolean = false, rendering: boolean = true): void {
    const shapeChanged = this.redrawShape(state, force, rendering);

    if (state.shape != null &amp;&amp; rendering) {
      this.redrawLabel(state, shapeChanged);
      this.redrawCellOverlays(state, shapeChanged);
      this.redrawControl(state, shapeChanged);
    }
  }

  /**
   * Redraws the shape for the given cell state.
   *
   * @param state &lt;CellState> whose label should be redrawn.
   */
  redrawShape(
    state: CellState,
    force: boolean = false,
    rendering: boolean = true
  ): boolean {
    let shapeChanged = false;
    const graph = &lt;Graph>state.view.graph;

    // Forces creation of new shape if shape style has changed
    if (
      state.shape != null &amp;&amp;
      state.shape.style != null &amp;&amp;
      state.style != null &amp;&amp;
      state.shape.style.shape !== state.style.shape
    ) {
      state.shape.destroy();
      state.shape = null;
    }

    if (
      state.shape == null &amp;&amp;
      graph.container != null &amp;&amp;
      state.cell !== state.view.currentRoot &amp;&amp;
      (state.cell.isVertex() || state.cell.isEdge())
    ) {
      state.shape = this.createShape(state);

      if (state.shape != null) {
        state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
        state.shape.antiAlias = this.antiAlias;

        this.createIndicatorShape(state);
        this.initializeShape(state);
        this.createCellOverlays(state);
        this.installListeners(state);

        // Forces a refresh of the handler if one exists
        const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler') as SelectionCellsHandler;
        selectionCellsHandler.updateHandler(state);
      }
    } else if (
      !force &amp;&amp;
      state.shape != null &amp;&amp;
      (!equalEntries(state.shape.style, state.style) ||
        this.checkPlaceholderStyles(state))
    ) {
      state.shape.resetStyles();
      this.configureShape(state);
      // LATER: Ignore update for realtime to fix reset of current gesture
      const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler') as SelectionCellsHandler;
      selectionCellsHandler.updateHandler(state);
      force = true;
    }

    // Updates indicator shape
    if (
      state.shape != null &amp;&amp;
      state.shape.indicatorShape != this.getShape(&lt;string>state.getIndicatorShape())
    ) {
      if (state.shape.indicator != null) {
        state.shape.indicator.destroy();
        state.shape.indicator = null;
      }

      this.createIndicatorShape(state);

      if (state.shape.indicatorShape != null) {
        state.shape.indicator = new state.shape.indicatorShape();
        state.shape.indicator.dialect = state.shape.dialect;
        state.shape.indicator.init(state.node as HTMLElement);
        force = true;
      }
    }

    if (state.shape) {
      // Handles changes of the collapse icon
      this.createControl(state);

      // Redraws the cell if required, ignores changes to bounds if points are
      // defined as the bounds are updated for the given points inside the shape
      if (force || this.isShapeInvalid(state, state.shape)) {
        if (state.absolutePoints.length > 0) {
          state.shape.points = state.absolutePoints.slice();
          state.shape.bounds = null;
        } else {
          state.shape.points = [];
          state.shape.bounds = new Rectangle(state.x, state.y, state.width, state.height);
        }

        state.shape.scale = state.view.scale;

        if (rendering == null || rendering) {
          this.doRedrawShape(state);
        } else {
          state.shape.updateBoundingBox();
        }

        shapeChanged = true;
      }
    }

    return shapeChanged;
  }

  /**
   * Invokes redraw on the shape of the given state.
   */
  doRedrawShape(state: CellState): void {
    state.shape?.redraw();
  }

  /**
   * Returns true if the given shape must be repainted.
   */
  isShapeInvalid(state: CellState, shape: Shape): boolean {
    return (
      shape.bounds == null ||
      shape.scale !== state.view.scale ||
      (state.absolutePoints.length === 0 &amp;&amp; !shape.bounds.equals(state)) ||
      (state.absolutePoints.length > 0 &amp;&amp;
        !equalPoints(shape.points, state.absolutePoints))
    );
  }

  /**
   * Destroys the shapes associated with the given cell state.
   *
   * @param state &lt;CellState> for which the shapes should be destroyed.
   */
  destroy(state: CellState) {
    if (state.shape) {
      if (state.text) {
        state.text.destroy();
        state.text = null;
      }

      state.overlays.visit((id: string, shape: Shape) => {
        shape.destroy();
      });

      state.overlays = new Dictionary();

      if (state.control) {
        state.control.destroy();
        state.control = null;
      }

      state.shape.destroy();
      state.shape = null;
    }
  }
}

// Add default shapes into the default shapes array
for (const [shapeName, shapeClass] of [
  [SHAPE.RECTANGLE, RectangleShape],
  [SHAPE.ELLIPSE, EllipseShape],
  [SHAPE.RHOMBUS, RhombusShape],
  [SHAPE.CYLINDER, CylinderShape],
  [SHAPE.CONNECTOR, ConnectorShape],
  [SHAPE.ACTOR, ActorShape],
  [SHAPE.TRIANGLE, TriangleShape],
  [SHAPE.HEXAGON, HexagonShape],
  [SHAPE.CLOUD, CloudShape],
  [SHAPE.LINE, LineShape],
  [SHAPE.ARROW, ArrowShape],
  [SHAPE.ARROW_CONNECTOR, ArrowConnectorShape],
  [SHAPE.DOUBLE_ELLIPSE, DoubleEllipseShape],
  [SHAPE.SWIMLANE, SwimlaneShape],
  [SHAPE.IMAGE, ImageShape],
  [SHAPE.LABEL, LabelShape],
]) {
  // @ts-ignore
  CellRenderer.registerShape(shapeName, shapeClass);
}

export default CellRenderer;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
