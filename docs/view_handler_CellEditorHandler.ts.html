

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/handler/CellEditorHandler.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/handler/CellEditorHandler.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2015, JGraph Ltd
 * Copyright (c) 2006-2015, Gaudenz Alder
 * Updated to ES9 syntax by David Morrissey 2021
 * Type definitions from the typed-mxgraph project
 */

import { getValue } from '../../util/utils';
import {
  getAlignmentAsPoint,
  setPrefixedStyle,
} from '../../util/styleUtils';
import Rectangle from '../geometry/Rectangle';
import InternalEvent from '../event/InternalEvent';
import Client from '../../Client';
import {
  ABSOLUTE_LINE_HEIGHT,
  ALIGN,
  DEFAULT_FONTFAMILY,
  DEFAULT_FONTSIZE,
  DEFAULT_TEXT_DIRECTION,
  DIALECT,
  FONT,
  LINE_HEIGHT,
  NONE,
  WORD_WRAP,
} from '../../util/constants';
import TextShape from '../geometry/node/TextShape';
import Cell from '../cell/Cell';
import InternalMouseEvent from '../event/InternalMouseEvent';
import CellState from '../cell/CellState';
import Shape from '../geometry/Shape';
import { clearSelection, extractTextWithWhitespace, isNode } from '../../util/domUtils';
import { getStringValue, htmlEntities, replaceTrailingNewlines } from '../../util/stringUtils';
import {
  getSource,
  isConsumed,
  isControlDown,
  isMetaDown,
  isShiftDown,
} from '../../util/eventUtils';
import EventSource from '../event/EventSource';

import type { Graph } from '../Graph';
import type { GraphPlugin } from '../../types';
import CellArray from '../cell/CellArray';
import TooltipHandler from './TooltipHandler';

/**
 * In-place editor for the graph. To control this editor, use
 * &lt;mxGraph.invokesStopCellEditing>, &lt;mxGraph.enterStopsCellEditing> and
 * &lt;mxGraph.escapeEnabled>. If &lt;mxGraph.enterStopsCellEditing> is true then
 * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and
 * escape keys can always be used to stop editing.
 *
 * To customize the location of the textbox in the graph, override
 * &lt;getEditorBounds> as follows:
 *
 * ```javascript
 * graph.cellEditor.getEditorBounds = (state)=>
 * {
 *   let result = getEditorBounds.apply(this, arguments);
 *
 *   if (this.graph.getModel().isEdge(state.cell))
 *   {
 *     result.x = state.getCenterX() - result.width / 2;
 *     result.y = state.getCenterY() - result.height / 2;
 *   }
 *
 *   return result;
 * };
 * ```
 *
 * Note that this hook is only called if &lt;autoSize> is false. If &lt;autoSize> is true,
 * then &lt;mxShape.getLabelBounds> is used to compute the current bounds of the textbox.
 *
 * The textarea uses the mxCellEditor CSS class. You can modify this class in
 * your custom CSS. Note: You should modify the CSS after loading the client
 * in the page.
 *
 * Example:
 *
 * To only allow numeric input in the in-place editor, use the following code.
 *
 * ```javascript
 * let text = graph.cellEditor.textarea;
 *
 * mxEvent.addListener(text, 'keydown', function (evt)
 * {
 *   if (!(evt.keyCode >= 48 &amp;&amp; evt.keyCode &lt;= 57) &amp;&amp;
 *       !(evt.keyCode >= 96 &amp;&amp; evt.keyCode &lt;= 105))
 *   {
 *     mxEvent.consume(evt);
 *   }
 * });
 * ```
 *
 * Placeholder:
 *
 * To implement a placeholder for cells without a label, use the
 * &lt;emptyLabelText> variable.
 *
 * Resize in Chrome:
 *
 * Resize of the textarea is disabled by default. If you want to enable
 * this feature extend &lt;init> and set this.textarea.style.resize = ''.
 *
 * To start editing on a key press event, the container of the graph
 * should have focus or a focusable parent should be used to add the
 * key press handler as follows.
 *
 * ```javascript
 * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>
 * {
 *   if (!graph.isEditing() &amp;&amp; !graph.isSelectionEmpty() &amp;&amp; evt.which !== 0 &amp;&amp;
 *       !mxEvent.isAltDown(evt) &amp;&amp; !mxEvent.isControlDown(evt) &amp;&amp; !mxEvent.isMetaDown(evt))
 *   {
 *     graph.startEditing();
 *
 *     if (Client.IS_FF)
 *     {
 *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);
 *     }
 *   }
 * }));
 * ```
 *
 * To allow focus for a DIV, and hence to receive key press events, some browsers
 * require it to have a valid tabindex attribute. In this case the following
 * code may be used to keep the container focused.
 *
 * ```javascript
 * let graphFireMouseEvent = graph.fireMouseEvent;
 * graph.fireMouseEvent = (evtName, me, sender)=>
 * {
 *   if (evtName == mxEvent.MOUSE_DOWN)
 *   {
 *     this.container.focus();
 *   }
 *
 *   graphFireMouseEvent.apply(this, arguments);
 * };
 * ```
 *
 * Constructor: mxCellEditor
 *
 * Constructs a new in-place editor for the specified graph.
 *
 * @param graph Reference to the enclosing &lt;mxGraph>.
 */
class CellEditorHandler implements GraphPlugin {
  static pluginId = 'CellEditorHandler';

  constructor(graph: Graph) {
    this.graph = graph;

    // Stops editing after zoom changes
    this.zoomHandler = () => {
      if (this.graph.isEditing()) {
        this.resize();
      }
    };

    // Handling of deleted cells while editing
    this.changeHandler = (sender: EventSource) => {
      if (this.editingCell &amp;&amp; !this.graph.getView().getState(this.editingCell, false)) {
        this.stopEditing(true);
      }
    };

    this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);
    this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);
    this.graph.getModel().addListener(InternalEvent.CHANGE, this.changeHandler);
  }

  // TODO: Document me!
  changeHandler: (sender: EventSource) => void;

  zoomHandler: () => void;

  clearOnChange: boolean = false;

  bounds: Rectangle | null = null;

  resizeThread: number | null = null;

  textDirection: '' | 'auto' | 'ltr' | 'rtl' | null = null;

  /**
   * Reference to the enclosing &lt;mxGraph>.
   */
  graph: Graph;

  /**
   * Holds the DIV that is used for text editing. Note that this may be null before the first
   * edit. Instantiated in &lt;init>.
   */
  textarea: HTMLElement | null = null;

  /**
   * Reference to the &lt;Cell> that is currently being edited.
   */
  // editingCell: mxCell;
  editingCell: Cell | null = null;

  /**
   * Reference to the event that was used to start editing.
   */
  // trigger: MouseEvent;
  trigger: InternalMouseEvent | MouseEvent | null = null;

  /**
   * Specifies if the label has been modified.
   */
  // modified: boolean;
  modified: boolean = false;

  /**
   * Specifies if the textarea should be resized while the text is being edited.
   * Default is true.
   */
  // autoSize: boolean;
  autoSize: boolean = true;

  /**
   * Specifies if the text should be selected when editing starts. Default is
   * true.
   */
  // selectText: boolean;
  selectText: boolean = true;

  /**
   * Text to be displayed for empty labels. Default is '' or '&lt;br>' in Firefox as
   * a workaround for the missing cursor bug for empty content editable. This can
   * be set to eg. "[Type Here]" to easier visualize editing of empty labels. The
   * value is only displayed before the first keystroke and is never used as the
   * actual editing value.
   */
  // emptyLabelText: '&lt;br>' | '';
  emptyLabelText: string = Client.IS_FF ? '&lt;br>' : '';

  /**
   * If true, pressing the escape key will stop editing and not accept the new
   * value. Change this to false to accept the new value on escape, and cancel
   * editing on Shift+Escape instead. Default is true.
   */
  // escapeCancelsEditing: boolean;
  escapeCancelsEditing: boolean = true;

  /**
   * Reference to the label DOM node that has been hidden.
   */
  // textNode: string;
  textNode: SVGGElement | null = null;

  /**
   * Specifies the zIndex for the textarea. Default is 5.
   */
  // zIndex: number;
  zIndex: number = 5;

  /**
   * Defines the minimum width and height to be used in &lt;resize>. Default is 0x20px.
   */
  // minResize: mxRectangle;
  minResize: Rectangle = new Rectangle(0, 20);

  /**
   * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE
   * 11 and 1 in all other browsers and modes.
   */
  // wordWrapPadding: 2 | 1 | 0;
  wordWrapPadding: number = 0;

  /**
   * If &lt;focusLost> should be called if &lt;textarea> loses the focus. Default is false.
   */
  // blurEnabled: boolean;
  blurEnabled: boolean = false;

  /**
   * Holds the initial editing value to check if the current value was modified.
   */
  // initialValue: string;
  initialValue: string | null = null;

  /**
   * Holds the current temporary horizontal alignment for the cell style. If this
   * is modified then the current text alignment is changed and the cell style is
   * updated when the value is applied.
   */
  align: string | null = null;

  /**
   * Creates the &lt;textarea> and installs the event listeners. The key handler
   * updates the &lt;modified> state.
   */
  init() {
    this.textarea = document.createElement('div');
    this.textarea.className = 'mxCellEditor mxPlainTextEditor';
    this.textarea.contentEditable = String(true);

    // Workaround for selection outside of DIV if height is 0
    if (Client.IS_GC) {
      this.textarea.style.minHeight = '1em';
    }

    this.textarea.style.position = 'relative';
    this.installListeners(this.textarea);
  }

  /**
   * Called in &lt;stopEditing> if cancel is false to invoke &lt;mxGraph.labelChanged>.
   */
  // applyValue(state: CellState, value: string): void;
  applyValue(state: CellState, value: any) {
    this.graph.labelChanged(state.cell, value, &lt;InternalMouseEvent>this.trigger);
  }

  /**
   * Sets the temporary horizontal alignment for the current editing session.
   */
  setAlign(align: string) {
    if (this.textarea) {
      this.textarea.style.textAlign = align;
    }

    this.align = align;
    this.resize();
  }

  /**
   * Gets the initial editing value for the given cell.
   */
  getInitialValue(state: CellState, trigger: MouseEvent | null) {
    let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);
    result = replaceTrailingNewlines(result, '&lt;div>&lt;br>&lt;/div>');
    return result.replace(/\n/g, '&lt;br>');
  }

  /**
   * Returns the current editing value.
   */
  getCurrentValue(state: CellState) {
    if (!this.textarea) return null;

    return extractTextWithWhitespace(&lt;Element[]>Array.from(this.textarea.childNodes));
  }

  /**
   * Returns true if &lt;escapeCancelsEditing> is true and shift, control and meta
   * are not pressed.
   */
  // isCancelEditingKeyEvent(evt: Event): boolean;
  isCancelEditingKeyEvent(evt: MouseEvent | KeyboardEvent) {
    return (
      this.escapeCancelsEditing ||
      isShiftDown(&lt;MouseEvent>(&lt;unknown>evt)) ||
      isControlDown(&lt;MouseEvent>(&lt;unknown>evt)) ||
      isMetaDown(&lt;MouseEvent>(&lt;unknown>evt))
    );
  }

  /**
   * Installs listeners for focus, change and standard key event handling.
   */
  // installListeners(elt: Element): void;
  installListeners(elt: HTMLElement) {
    // Applies value if text is dragged
    // LATER: Gesture mouse events ignored for starting move
    InternalEvent.addListener(elt, 'dragstart', (evt: Event) => {
      this.graph.stopEditing(false);
      InternalEvent.consume(evt);
    });

    // Applies value if focus is lost
    InternalEvent.addListener(elt, 'blur', (evt: Event) => {
      if (this.blurEnabled) {
        this.focusLost();
      }
    });

    // Updates modified state and handles placeholder text
    InternalEvent.addListener(elt, 'keydown', (evt: KeyboardEvent) => {
      if (!isConsumed(evt)) {
        if (this.isStopEditingEvent(evt)) {
          this.graph.stopEditing(false);
          InternalEvent.consume(evt);
        } else if (evt.keyCode === 27 /* Escape */) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));
          InternalEvent.consume(evt);
        }
      }
    });

    // Keypress only fires if printable key was pressed and handles removing the empty placeholder
    const keypressHandler = (evt: KeyboardEvent) => {
      if (this.editingCell != null) {
        // Clears the initial empty label on the first keystroke
        // and workaround for FF which fires keypress for delete and backspace
        if (
          this.clearOnChange &amp;&amp;
          elt.innerHTML === this.getEmptyLabelText() &amp;&amp;
          (!Client.IS_FF ||
            (evt.keyCode !== 8 /* Backspace */ &amp;&amp; evt.keyCode !== 46)) /* Delete */
        ) {
          this.clearOnChange = false;
          elt.innerHTML = '';
        }
      }
    };

    InternalEvent.addListener(elt, 'keypress', keypressHandler);
    InternalEvent.addListener(elt, 'paste', keypressHandler);

    // Handler for updating the empty label text value after a change
    const keyupHandler = (evt: KeyboardEvent) => {
      if (this.editingCell != null) {
        // Uses an optional text value for sempty labels which is cleared
        // when the first keystroke appears. This makes it easier to see
        // that a label is being edited even if the label is empty.
        // In Safari and FF, an empty text is represented by &lt;BR> which isn't enough to force a valid size
        const textarea = &lt;HTMLElement>this.textarea;

        if (textarea.innerHTML.length === 0 || textarea.innerHTML === '&lt;br>') {
          textarea.innerHTML = this.getEmptyLabelText();
          this.clearOnChange = textarea.innerHTML.length > 0;
        } else {
          this.clearOnChange = false;
        }
      }
    };

    InternalEvent.addListener(elt, 'input', keyupHandler);
    InternalEvent.addListener(elt, 'cut', keyupHandler);
    InternalEvent.addListener(elt, 'paste', keyupHandler);

    // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events
    const evtName = 'input';

    const resizeHandler = (evt: MouseEvent) => {
      if (this.editingCell != null &amp;&amp; this.autoSize &amp;&amp; !isConsumed(evt)) {
        // Asynchronous is needed for keydown and shows better results for input events overall
        // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)
        if (this.resizeThread != null) {
          window.clearTimeout(this.resizeThread);
        }

        this.resizeThread = window.setTimeout(() => {
          this.resizeThread = null;
          this.resize();
        }, 0);
      }
    };

    InternalEvent.addListener(elt, evtName, resizeHandler);
    InternalEvent.addListener(window, 'resize', resizeHandler);
    InternalEvent.addListener(elt, 'cut', resizeHandler);
    InternalEvent.addListener(elt, 'paste', resizeHandler);
  }

  /**
   * Returns true if the given keydown event should stop cell editing. This
   * returns true if F2 is pressed of if &lt;mxGraph.enterStopsCellEditing> is true
   * and enter is pressed without control or shift.
   */
  isStopEditingEvent(evt: KeyboardEvent) {
    return (
      evt.keyCode === 113 /* F2 */ ||
      (this.graph.isEnterStopsCellEditing() &amp;&amp;
        evt.keyCode === 13 /* Enter */ &amp;&amp;
        !isControlDown(&lt;MouseEvent>(&lt;unknown>evt)) &amp;&amp;
        !isShiftDown(&lt;MouseEvent>(&lt;unknown>evt)))
    );
  }

  /**
   * Returns true if this editor is the source for the given native event.
   */
  isEventSource(evt: MouseEvent | KeyboardEvent) {
    return getSource(evt) === this.textarea;
  }

  /**
   * Returns &lt;modified>.
   */
  resize() {
    const state = this.editingCell
      ? this.graph.getView().getState(this.editingCell)
      : null;

    if (!state) {
      this.stopEditing(true);
    } else if (this.textarea != null) {
      const isEdge = state.cell.isEdge();
      const { scale } = this.graph.getView();
      let m = null;

      if (!this.autoSize || state.style.overflow === 'fill') {
        // Specifies the bounds of the editor box
        this.bounds = &lt;Rectangle>this.getEditorBounds(state);
        this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;
        this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;

        // FIXME: Offset when scaled
        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;
        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;

        // Installs native word wrapping and avoids word wrap for empty label placeholder
        if (
          this.graph.isWrapping(state.cell) &amp;&amp;
          (this.bounds.width >= 2 || this.bounds.height >= 2) &amp;&amp;
          this.textarea.innerHTML !== this.getEmptyLabelText()
        ) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = 'normal';

          if (state.style.overflow !== 'fill') {
            this.textarea.style.width = `${
              Math.round(this.bounds.width / scale) + this.wordWrapPadding
            }px`;
          }
        } else {
          this.textarea.style.whiteSpace = 'nowrap';

          if (state.style.overflow !== 'fill') {
            this.textarea.style.width = '';
          }
        }
      } else {
        const lw = getValue(state.style, 'labelWidth', null);
        m = state.text != null &amp;&amp; this.align == null ? state.text.margin : null;

        if (m == null) {
          m = getAlignmentAsPoint(
            this.align || getValue(state.style, 'align', ALIGN.CENTER),
            getValue(state.style, 'verticalAlign', ALIGN.MIDDLE)
          );
        }

        if (isEdge) {
          this.bounds = new Rectangle(
            state.absoluteOffset.x,
            state.absoluteOffset.y,
            0,
            0
          );

          if (lw != null) {
            const tmp = (parseFloat(lw) + 2) * scale;
            this.bounds.width = tmp;
            this.bounds.x += m.x * tmp;
          }
        } else {
          let bounds = Rectangle.fromRectangle(state);
          let hpos = getValue(state.style, 'labelPosition', ALIGN.CENTER);
          let vpos = getValue(state.style, 'verticalLabelPosition', ALIGN.MIDDLE);

          bounds =
            state.shape != null &amp;&amp; hpos === 'center' &amp;&amp; vpos === 'middle'
              ? state.shape.getLabelBounds(bounds)
              : bounds;

          if (lw != null) {
            bounds.width = parseFloat(lw) * scale;
          }

          if (
            !(&lt;Graph>state.view.graph).cellRenderer.legacySpacing ||
            state.style.overflow !== 'width'
          ) {
            // @ts-ignore
            const dummy = new TextShape(); // FIXME!!!! ===================================================================================================
            const spacing = (state.style.spacing ?? 2) * scale;
            const spacingTop =
              ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
            const spacingRight =
              ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale +
              spacing;
            const spacingBottom =
              ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale +
              spacing;
            const spacingLeft =
              ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;

            hpos =
              state.style.labelPosition != null ? state.style.labelPosition : 'center';
            vpos =
              state.style.verticalLabelPosition != null
                ? state.style.verticalLabelPosition
                : 'middle';

            bounds = new Rectangle(
              bounds.x + spacingLeft,
              bounds.y + spacingTop,
              bounds.width -
                (hpos === ALIGN.CENTER &amp;&amp; lw == null ? spacingLeft + spacingRight : 0),
              bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0)
            );
          }

          this.bounds = new Rectangle(
            bounds.x + state.absoluteOffset.x,
            bounds.y + state.absoluteOffset.y,
            bounds.width,
            bounds.height
          );
        }

        // Needed for word wrap inside text blocks with oversize lines to match the final result where
        // the width of the longest line is used as the reference for text alignment in the cell
        // TODO: Fix word wrapping preview for edge labels in helloworld.html
        if (
          this.graph.isWrapping(state.cell) &amp;&amp;
          (this.bounds.width >= 2 || this.bounds.height >= 2) &amp;&amp;
          this.textarea.innerHTML !== this.getEmptyLabelText()
        ) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = 'normal';

          // Forces automatic reflow if text is removed from an oversize label and normal word wrap
          const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;

          if (this.textarea.style.position !== 'relative') {
            this.textarea.style.width = `${tmp}px`;

            if (this.textarea.scrollWidth > tmp) {
              this.textarea.style.width = `${this.textarea.scrollWidth}px`;
            }
          } else {
            this.textarea.style.maxWidth = `${tmp}px`;
          }
        } else {
          // KNOWN: Trailing cursor in IE9 quirks mode is not visible
          this.textarea.style.whiteSpace = 'nowrap';
          this.textarea.style.width = '';
        }

        const ow = this.textarea.scrollWidth;
        const oh = this.textarea.scrollHeight;

        // TODO: Update CSS width and height if smaller than minResize or remove minResize
        // if (this.minResize != null)
        // {
        //  ow = Math.max(ow, this.minResize.width);
        //  oh = Math.max(oh, this.minResize.height);
        // }

        // LATER: Keep in visible area, add fine tuning for pixel precision
        this.textarea.style.left = `${Math.max(
          0,
          Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1
        )}px`;
        this.textarea.style.top = `${Math.max(
          0,
          Math.round(
            this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)
          ) + 1
        )}px`;
      }

      setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');
      setPrefixedStyle(
        this.textarea.style,
        'transform',
        `scale(${scale},${scale})${
          m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`
        }`
      );
    }
  }

  /**
   * Called if the textarea has lost focus.
   */
  focusLost() {
    this.stopEditing(!this.graph.isInvokesStopCellEditing());
  }

  /**
   * Returns the background color for the in-place editor. This implementation
   * always returns NONE.
   */
  getBackgroundColor(state: CellState) {
    return NONE;
  }

  /**
   * Starts the editor for the given cell.
   *
   * @param cell &lt;Cell> to start editing.
   * @param trigger Optional mouse event that triggered the editor.
   */
  startEditing(cell: Cell, trigger: MouseEvent | null = null) {
    this.stopEditing(true);
    this.align = null;

    // Creates new textarea instance
    if (this.textarea == null) {
      this.init();
    }

    const tooltipHandler = this.graph.getPlugin('TooltipHandler') as TooltipHandler;

    if (tooltipHandler) {
      tooltipHandler.hideTooltip();
    }

    const state = this.graph.getView().getState(cell);

    if (state) {
      // Configures the style of the in-place editor
      const { scale } = this.graph.getView();
      const size = state.style.fontSize ?? DEFAULT_FONTSIZE;
      const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;
      const color = state.style.fontColor ?? 'black';
      const align = state.style.align ?? ALIGN.LEFT;
      const bold = (state.style.fontStyle || 0) &amp; FONT.BOLD;
      const italic = (state.style.fontStyle || 0) &amp; FONT.ITALIC;

      const txtDecor = [];
      if ((state.style.fontStyle || 0) &amp; FONT.UNDERLINE) {
        txtDecor.push('underline');
      }
      if ((state.style.fontStyle || 0) &amp; FONT.STRIKETHROUGH) {
        txtDecor.push('line-through');
      }

      const textarea = &lt;HTMLElement>this.textarea;
      textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT
        ? `${Math.round(size * LINE_HEIGHT)}px`
        : String(LINE_HEIGHT);
      textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';
      textarea.style.textDecoration = txtDecor.join(' ');
      textarea.style.fontWeight = bold ? 'bold' : 'normal';
      textarea.style.fontStyle = italic ? 'italic' : '';
      textarea.style.fontSize = `${Math.round(size)}px`;
      textarea.style.zIndex = String(this.zIndex);
      textarea.style.fontFamily = family;
      textarea.style.textAlign = align;
      textarea.style.outline = 'none';
      textarea.style.color = color;

      let dir = (this.textDirection =
        state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);

      if (dir === 'auto') {
        if (
          state.text !== null &amp;&amp;
          state.text.dialect !== DIALECT.STRICTHTML &amp;&amp;
          !isNode(state.text.value)
        ) {
          dir = state.text.getAutoDirection();
        }
      }

      if (dir === 'ltr' || dir === 'rtl') {
        textarea.setAttribute('dir', dir);
      } else {
        textarea.removeAttribute('dir');
      }

      // Sets the initial editing value
      textarea.innerHTML = this.getInitialValue(state, trigger) || '';
      this.initialValue = textarea.innerHTML;

      // Uses an optional text value for empty labels which is cleared
      // when the first keystroke appears. This makes it easier to see
      // that a label is being edited even if the label is empty.
      if (textarea.innerHTML.length === 0 || textarea.innerHTML === '&lt;br>') {
        textarea.innerHTML = &lt;string>this.getEmptyLabelText();
        this.clearOnChange = true;
      } else {
        this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();
      }

      // @ts-ignore
      this.graph.container.appendChild(textarea);

      // Update this after firing all potential events that could update the cleanOnChange flag
      this.editingCell = cell;
      this.trigger = trigger;
      this.textNode = null;

      if (state.text !== null &amp;&amp; this.isHideLabel(state)) {
        this.textNode = &lt;SVGGElement>state.text.node;
        this.textNode.style.visibility = 'hidden';
      }

      // Workaround for initial offsetHeight not ready for heading in markup
      if (
        this.autoSize &amp;&amp;
        // @ts-ignore
        (this.graph.model.isEdge(state.cell) || state.style.overflow !== 'fill')
      ) {
        window.setTimeout(() => {
          this.resize();
        }, 0);
      }

      this.resize();

      // Workaround for NS_ERROR_FAILURE in FF
      try {
        // Prefers blinking cursor over no selected text if empty
        textarea.focus();

        if (
          this.isSelectText() &amp;&amp;
          textarea.innerHTML.length > 0 &amp;&amp;
          (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)
        ) {
          document.execCommand('selectAll', false);
        }
      } catch (e) {
        // ignore
      }
    }
  }

  /**
   * Returns &lt;selectText>.
   */
  isSelectText() {
    return this.selectText;
  }

  /**
  clearSelection() {
    const selection = window.getSelection();

    if (selection) {
      if (selection.empty) {
        selection.empty();
      } else if (selection.removeAllRanges) {
        selection.removeAllRanges();
      }
    }
  }

  /**
   * Stops the editor and applies the value if cancel is false.
   */
  stopEditing(cancel: boolean = false) {
    if (this.editingCell) {
      if (this.textNode) {
        this.textNode.style.visibility = 'visible';
        this.textNode = null;
      }

      const state = !cancel ? this.graph.view.getState(this.editingCell) : null;
      const textarea = &lt;HTMLElement>this.textarea;

      const initial = this.initialValue;
      this.initialValue = null;
      this.editingCell = null;
      this.trigger = null;
      this.bounds = null;
      textarea.blur();
      clearSelection();

      if (textarea.parentNode) {
        textarea.parentNode.removeChild(textarea);
      }

      if (this.clearOnChange &amp;&amp; textarea.innerHTML === this.getEmptyLabelText()) {
        textarea.innerHTML = '';
        this.clearOnChange = false;
      }

      if (state &amp;&amp; (textarea.innerHTML !== initial || this.align !== null)) {
        this.prepareTextarea();
        const value = this.getCurrentValue(state);

        this.graph.getModel().beginUpdate();
        try {
          if (value !== null) {
            this.applyValue(state, value);
          }

          if (this.align !== null) {
            this.graph.setCellStyles('align', this.align, new CellArray(state.cell));
          }
        } finally {
          this.graph.getModel().endUpdate();
        }
      }

      // Forces new instance on next edit for undo history reset
      if (this.textarea) InternalEvent.release(this.textarea);

      this.textarea = null;
      this.align = null;
    }
  }

  /**
   * Prepares the textarea for getting its value in &lt;stopEditing>.
   * This implementation removes the extra trailing linefeed in Firefox.
   */
  prepareTextarea() {
    const textarea = &lt;HTMLElement>this.textarea;
    if (textarea.lastChild &amp;&amp; textarea.lastChild.nodeName === 'BR') {
      textarea.removeChild(textarea.lastChild);
    }
  }

  /**
   * Returns true if the label should be hidden while the cell is being
   * edited.
   */
  isHideLabel(state: CellState | null = null) {
    return true;
  }

  /**
   * Returns the minimum width and height for editing the given state.
   */
  getMinimumSize(state: CellState) {
    const { scale } = this.graph.getView();
    const textarea = &lt;HTMLElement>this.textarea;

    return new Rectangle(
      0,
      0,
      state.text === null ? 30 : state.text.size * scale + 20,
      textarea.style.textAlign === 'left' ? 120 : 40
    );
  }

  /**
   * Returns the &lt;mxRectangle> that defines the bounds of the editor.
   */
  getEditorBounds(state: CellState) {
    const isEdge = state.cell.isEdge();
    const { scale } = this.graph.getView();
    const minSize = this.getMinimumSize(state);
    const minWidth = minSize.width;
    const minHeight = minSize.height;
    let result = null;

    if (
      !isEdge &amp;&amp;
      (&lt;Graph>state.view.graph).cellRenderer.legacySpacing &amp;&amp;
      state.style.overflow === 'fill'
    ) {
      result = (&lt;Shape>state.shape).getLabelBounds(Rectangle.fromRectangle(state));
    } else {
      // @ts-ignore
      const dummy = new TextShape(); // FIXME!!!! ===================================================================================================
      const spacing: number = (state.style.spacing ?? 0) * scale;
      const spacingTop: number =
        ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
      const spacingRight: number =
        ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
      const spacingBottom: number =
        ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
      const spacingLeft: number =
        ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;

      result = new Rectangle(
        state.x,
        state.y,
        Math.max(minWidth, state.width - spacingLeft - spacingRight),
        Math.max(minHeight, state.height - spacingTop - spacingBottom)
      );
      const hpos: string =
        state.style.labelPosition != null ? state.style.labelPosition : 'center';
      const vpos: string =
        state.style.verticalLabelPosition != null
          ? state.style.verticalLabelPosition
          : 'middle';

      result =
        state.shape != null &amp;&amp; hpos === 'center' &amp;&amp; vpos === 'middle'
          ? state.shape.getLabelBounds(result)
          : result;

      if (isEdge) {
        result.x = state.absoluteOffset.x;
        result.y = state.absoluteOffset.y;

        if (state.text != null &amp;&amp; state.text.boundingBox != null) {
          // Workaround for label containing just spaces in which case
          // the bounding box location contains negative numbers
          if (state.text.boundingBox.x > 0) {
            result.x = state.text.boundingBox.x;
          }

          if (state.text.boundingBox.y > 0) {
            result.y = state.text.boundingBox.y;
          }
        }
      } else if (state.text != null &amp;&amp; state.text.boundingBox != null) {
        result.x = Math.min(result.x, state.text.boundingBox.x);
        result.y = Math.min(result.y, state.text.boundingBox.y);
      }

      result.x += spacingLeft;
      result.y += spacingTop;

      if (state.text != null &amp;&amp; state.text.boundingBox != null) {
        if (!isEdge) {
          result.width = Math.max(result.width, state.text.boundingBox.width);
          result.height = Math.max(result.height, state.text.boundingBox.height);
        } else {
          result.width = Math.max(minWidth, state.text.boundingBox.width);
          result.height = Math.max(minHeight, state.text.boundingBox.height);
        }
      }

      // Applies the horizontal and vertical label positions
      if (state.cell.isVertex()) {
        const horizontal: string = &lt;string>(
          getStringValue(state.style, 'labelPosition', ALIGN.CENTER)
        );

        if (horizontal === 'left') {
          result.x -= state.width;
        } else if (horizontal === 'right') {
          result.x += state.width;
        }

        const vertical: string =
          state.style.verticalLabelPosition != null
            ? state.style.verticalLabelPosition
            : 'middle';

        if (vertical === 'top') {
          result.y -= state.height;
        } else if (vertical === 'bottom') {
          result.y += state.height;
        }
      }
    }

    return new Rectangle(
      Math.round(result.x),
      Math.round(result.y),
      Math.round(result.width),
      Math.round(result.height)
    );
  }

  /**
   * Returns the initial label value to be used of the label of the given
   * cell is empty. This label is displayed and cleared on the first keystroke.
   * This implementation returns &lt;emptyLabelText>.
   *
   * @param cell &lt;Cell> for which a text for an empty editing box should be
   * returned.
   */
  getEmptyLabelText(cell: Cell | null = null) {
    return this.emptyLabelText ?? '';
  }

  /**
   * Returns the cell that is currently being edited or null if no cell is
   * being edited.
   */
  getEditingCell() {
    return this.editingCell;
  }

  /**
   * Destroys the editor and removes all associated resources.
   */
  onDestroy() {
    if (this.textarea) {
      InternalEvent.release(this.textarea);
      if (this.textarea.parentNode) {
        this.textarea.parentNode.removeChild(this.textarea);
      }
      this.textarea = null;
    }

    this.graph.getModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.zoomHandler);
  }
}

export default CellEditorHandler;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
