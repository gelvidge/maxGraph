

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/handler/ConnectionHandler.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/handler/ConnectionHandler.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2016, JGraph Ltd
 * Copyright (c) 2006-2016, Gaudenz Alder
 */
import Geometry from '../geometry/Geometry';
import Cell from '../cell/Cell';
import Point from '../geometry/Point';
import EventObject from '../event/EventObject';
import InternalEvent from '../event/InternalEvent';
import {
  CURSOR,
  DEFAULT_VALID_COLOR,
  DIALECT,
  HIGHLIGHT_STROKEWIDTH,
  INVALID_COLOR,
  NONE,
  OUTLINE_HIGHLIGHT_COLOR,
  OUTLINE_HIGHLIGHT_STROKEWIDTH,
  TOOLTIP_VERTICAL_OFFSET,
  VALID_COLOR,
} from '../../util/constants';
import { getRotatedPoint, toRadians } from '../../util/mathUtils';
import { convertPoint, getOffset } from '../../util/styleUtils';
import InternalMouseEvent from '../event/InternalMouseEvent';
import ImageShape from '../geometry/node/ImageShape';
import CellMarker from '../cell/CellMarker';
import ConstraintHandler from './ConstraintHandler';
import PolylineShape from '../geometry/edge/PolylineShape';
import EventSource from '../event/EventSource';
import Rectangle from '../geometry/Rectangle';
import MaxLog from '../../gui/MaxLog';
import {
  getClientX,
  getClientY,
  isAltDown,
  isConsumed,
  isShiftDown,
} from '../../util/eventUtils';
import Image from '../image/ImageBox';
import CellState from '../cell/CellState';
import { Graph } from '../Graph';
import ConnectionConstraint from '../other/ConnectionConstraint';
import Shape from '../geometry/Shape';
import { GraphPlugin, Listenable } from '../../types';
import CellArray from '../cell/CellArray';

type FactoryMethod = (source: Cell | null, target: Cell | null, style?: string) => Cell;

/**
 * Graph event handler that creates new connections. Uses &lt;mxTerminalMarker>
 * for finding and highlighting the source and target vertices and
 * &lt;factoryMethod> to create the edge instance. This handler is built-into
 * &lt;mxGraph.connectionHandler> and enabled using &lt;mxGraph.setConnectable>.
 *
 * Example:
 *
 * ```javascript
 * new mxConnectionHandler(graph, (source, target, style)=>
 * {
 *   edge = new mxCell('', new mxGeometry());
 *   edge.setEdge(true);
 *   edge.setStyle(style);
 *   edge.geometry.relative = true;
 *   return edge;
 * });
 * ```
 *
 * Here is an alternative solution that just sets a specific user object for
 * new edges by overriding &lt;insertEdge>.
 *
 * ```javascript
 * mxConnectionHandlerInsertEdge = insertEdge;
 * insertEdge = (parent, id, value, source, target, style)=>
 * {
 *   value = 'Test';
 *
 *   return mxConnectionHandlerInsertEdge.apply(this, arguments);
 * };
 * ```
 *
 * Using images to trigger connections:
 *
 * This handler uses mxTerminalMarker to find the source and target cell for
 * the new connection and creates a new edge using &lt;connect>. The new edge is
 * created using &lt;createEdge> which in turn uses &lt;factoryMethod> or creates a
 * new default edge.
 *
 * The handler uses a "highlight-paradigm" for indicating if a cell is being
 * used as a source or target terminal, as seen in other diagramming products.
 * In order to allow both, moving and connecting cells at the same time,
 * &lt;mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot
 * of a cell, that is, the region of the cell which is used to trigger a new
 * connection. The constant is a value between 0 and 1 that specifies the
 * amount of the width and height around the center to be used for the hotspot
 * of a cell and its default value is 0.5. In addition,
 * &lt;mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the
 * width and height of the hotspot.
 *
 * This solution, while standards compliant, may be somewhat confusing because
 * there is no visual indicator for the hotspot and the highlight is seen to
 * switch on and off while the mouse is being moved in and out. Furthermore,
 * this paradigm does not allow to create different connections depending on
 * the highlighted hotspot as there is only one hotspot per cell and it
 * normally does not allow cells to be moved and connected at the same time as
 * there is no clear indication of the connectable area of the cell.
 *
 * To come across these issues, the handle has an additional &lt;createIcons> hook
 * with a default implementation that allows to create one icon to be used to
 * trigger new connections. If this icon is specified, then new connections can
 * only be created if the image is clicked while the cell is being highlighted.
 * The &lt;createIcons> hook may be overridden to create more than one
 * &lt;mxImageShape> for creating new connections, but the default implementation
 * supports one image and is used as follows:
 *
 * In order to display the "connect image" whenever the mouse is over the cell,
 * an DEFAULT_HOTSPOT of 1 should be used:
 *
 * ```javascript
 * mxConstants.DEFAULT_HOTSPOT = 1;
 * ```
 *
 * In order to avoid confusion with the highlighting, the highlight color
 * should not be used with a connect image:
 *
 * ```javascript
 * mxConstants.HIGHLIGHT_COLOR = null;
 * ```
 *
 * To install the image, the connectImage field of the mxConnectionHandler must
 * be assigned a new &lt;mxImage> instance:
 *
 * ```javascript
 * connectImage = new mxImage('images/green-dot.gif', 14, 14);
 * ```
 *
 * This will use the green-dot.gif with a width and height of 14 pixels as the
 * image to trigger new connections. In createIcons the icon field of the
 * handler will be set in order to remember the icon that has been clicked for
 * creating the new connection. This field will be available under selectedIcon
 * in the connect method, which may be overridden to take the icon that
 * triggered the new connection into account. This is useful if more than one
 * icon may be used to create a connection.
 *
 * Group: Events
 *
 * Event: mxEvent.START
 *
 * Fires when a new connection is being created by the user. The &lt;code>state&lt;/code>
 * property contains the state of the source cell.
 *
 * Event: mxEvent.CONNECT
 *
 * Fires between begin- and endUpdate in &lt;connect>. The &lt;code>cell&lt;/code>
 * property contains the inserted edge, the &lt;code>event&lt;/code> and &lt;code>target&lt;/code>
 * properties contain the respective arguments that were passed to &lt;connect> (where
 * target corresponds to the dropTarget argument). Finally, the &lt;code>terminal&lt;/code>
 * property corresponds to the target argument in &lt;connect> or the clone of the source
 * terminal if &lt;createTarget> is enabled.
 *
 * Note that the target is the cell under the mouse where the mouse button was released.
 * Depending on the logic in the handler, this doesn't necessarily have to be the target
 * of the inserted edge. To print the source, target or any optional ports IDs that the
 * edge is connected to, the following code can be used. To get more details about the
 * actual connection point, &lt;mxGraph.getConnectionConstraint> can be used. To resolve
 * the port IDs, use &lt;Transactions.getCell>.
 *
 * ```javascript
 * graph.connectionHandler.addListener(mxEvent.CONNECT, (sender, evt)=>
 * {
 *   let edge = evt.getProperty('cell');
 *   let source = graph.getModel().getTerminal(edge, true);
 *   let target = graph.getModel().getTerminal(edge, false);
 *
 *   let style = graph.getCellStyle(edge);
 *   let sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];
 *   let targetPortId = style[mxConstants.STYLE_TARGET_PORT];
 *
 *   MaxLog.show();
 *   MaxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);
 * });
 * ```
 *
 * Event: mxEvent.RESET
 *
 * Fires when the &lt;reset> method is invoked.
 *
 * Constructor: mxConnectionHandler
 *
 * Constructs an event handler that connects vertices using the specified
 * factory method to create the new edges. Modify
 * &lt;mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers
 * the creation of a new connection or use connect icons as explained
 * above.
 *
 * @param graph Reference to the enclosing &lt;mxGraph>.
 * @param factoryMethod Optional function to create the edge. The function takes
 * the source and target &lt;Cell> as the first and second argument and an
 * optional cell style from the preview as the third argument. It returns
 * the &lt;Cell> that represents the new edge.
 */
class ConnectionHandler extends EventSource implements GraphPlugin {
  static pluginId = 'ConnectionHandler';

  // TODO: Document me!
  previous: CellState | null = null;
  iconState: CellState | null = null;
  icons: ImageShape[] = [];
  cell: Cell | null = null;
  currentPoint: Point | null = null;
  sourceConstraint: ConnectionConstraint | null = null;
  shape: Shape | null = null;
  icon: ImageShape | null = null;
  originalPoint: Point | null = null;
  currentState: CellState | null = null;
  selectedIcon: ImageShape | null = null;
  waypoints: Point[] = [];

  /**
   * Reference to the enclosing &lt;mxGraph>.
   */
  graph: Graph;

  /**
   * Function that is used for creating new edges. The function takes the
   * source and target &lt;Cell> as the first and second argument and returns
   * a new &lt;Cell> that represents the edge. This is used in &lt;createEdge>.
   */
  factoryMethod: FactoryMethod | null = null;

  /**
   * Specifies if icons should be displayed inside the graph container instead
   * of the overlay pane. This is used for HTML labels on vertices which hide
   * the connect icon. This has precendence over &lt;moveIconBack> when set
   * to true. Default is false.
   */
  moveIconFront = false;

  /**
   * Specifies if icons should be moved to the back of the overlay pane. This can
   * be set to true if the icons of the connection handler conflict with other
   * handles, such as the vertex label move handle. Default is false.
   */
  moveIconBack = false;

  /**
   * &lt;mxImage> that is used to trigger the creation of a new connection. This
   * is used in &lt;createIcons>. Default is null.
   */

  connectImage: Image | null = null;

  /**
   * Specifies if the connect icon should be centered on the target state
   * while connections are being previewed. Default is false.
   */
  targetConnectImage = false;

  /**
   * Specifies if events are handled. Default is false.
   */
  enabled = false;

  /**
   * Specifies if new edges should be selected. Default is true.
   */
  select = true;

  /**
   * Specifies if &lt;createTargetVertex> should be called if no target was under the
   * mouse for the new connection. Setting this to true means the connection
   * will be drawn as valid if no target is under the mouse, and
   * &lt;createTargetVertex> will be called before the connection is created between
   * the source cell and the newly created vertex in &lt;createTargetVertex>, which
   * can be overridden to create a new target. Default is false.
   */
  createTarget = false;

  /**
   * Holds the &lt;mxTerminalMarker> used for finding source and target cells.
   */
  marker: CellMarker;

  /**
   * Holds the &lt;mxConstraintHandler> used for drawing and highlighting
   * constraints.
   */
  constraintHandler: ConstraintHandler;

  /**
   * Holds the current validation error while connections are being created.
   */
  error: string | null = null;

  /**
   * Specifies if single clicks should add waypoints on the new edge. Default is
   * false.
   */
  waypointsEnabled = false;

  /**
   * Specifies if the connection handler should ignore the state of the mouse
   * button when highlighting the source. Default is false, that is, the
   * handler only highlights the source if no button is being pressed.
   */
  ignoreMouseDown = false;

  /**
   * Holds the &lt;mxPoint> where the mouseDown took place while the handler is
   * active.
   */
  first: Point | null = null;

  /**
   * Holds the offset for connect icons during connection preview.
   * Default is mxPoint(0, &lt;mxConstants.TOOLTIP_VERTICAL_OFFSET>).
   * Note that placing the icon under the mouse pointer with an
   * offset of (0,0) will affect hit detection.
   */
  connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);

  /**
   * Optional &lt;CellState> that represents the preview edge while the
   * handler is active. This is created in &lt;createEdgeState>.
   */
  edgeState: CellState | null = null;

  /**
   * Holds the change event listener for later removal.
   */
  changeHandler: (sender: Listenable) => void;

  /**
   * Holds the drill event listener for later removal.
   */
  drillHandler: (sender: Listenable) => void;

  /**
   * Counts the number of mouseDown events since the start. The initial mouse
   * down event counts as 1.
   */
  mouseDownCounter = 0;

  /**
   * Switch to enable moving the preview away from the mousepointer. This is required in browsers
   * where the preview cannot be made transparent to events and if the built-in hit detection on
   * the HTML elements in the page should be used. Default is the value of &lt;Client.IS_VML>.
   */
  movePreviewAway = false;

  /**
   * Specifies if connections to the outline of a highlighted target should be
   * enabled. This will allow to place the connection point along the outline of
   * the highlighted target. Default is false.
   */
  outlineConnect = false;

  /**
   * Specifies if the actual shape of the edge state should be used for the preview.
   * Default is false. (Ignored if no edge state is created in &lt;createEdgeState>.)
   */
  livePreview = false;

  /**
   * Specifies the cursor to be used while the handler is active. Default is null.
   */
  cursor: string | null = null;

  /**
   * Specifies if new edges should be inserted before the source vertex in the
   * cell hierarchy. Default is false for backwards compatibility.
   */
  insertBeforeSource = false;

  escapeHandler: () => void;

  constructor(graph: Graph, factoryMethod: FactoryMethod | null = null) {
    super();

    this.graph = graph;
    this.factoryMethod = factoryMethod;

    this.graph.addMouseListener(this);
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler(this.graph);

    // Redraws the icons if the graph changes
    this.changeHandler = (sender: Listenable) => {
      if (this.iconState) {
        this.iconState = this.graph.getView().getState(this.iconState.cell);
      }

      if (this.iconState) {
        this.redrawIcons(this.icons, this.iconState);
        this.constraintHandler.reset();
      } else if (this.previous &amp;&amp; !this.graph.view.getState(this.previous.cell)) {
        this.reset();
      }
    };

    this.graph.getModel().addListener(InternalEvent.CHANGE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);
    this.graph
      .getView()
      .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);

    // Removes the icon if we step into/up or start editing
    this.drillHandler = (sender: Listenable) => {
      this.reset();
    };

    this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);
    this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);
    this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);

    // Handles escape keystrokes
    this.escapeHandler = () => {
      this.reset();
    };

    this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }

  /**
   * Returns true if events are handled. This implementation
   * returns &lt;enabled>.
   */
  isEnabled() {
    return this.enabled;
  }

  /**
   * Enables or disables event handling. This implementation
   * updates &lt;enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled: boolean) {
    this.enabled = enabled;
  }

  /**
   * Returns &lt;insertBeforeSource> for non-loops and false for loops.
   *
   * @param edge &lt;Cell> that represents the edge to be inserted.
   * @param source &lt;Cell> that represents the source terminal.
   * @param target &lt;Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget &lt;Cell> that represents the cell under the mouse when it was
   * released.
   */
  isInsertBefore(
    edge: Cell,
    source: Cell | null,
    target: Cell | null,
    evt: MouseEvent,
    dropTarget: Cell | null
  ) {
    return this.insertBeforeSource &amp;&amp; source !== target;
  }

  /**
   * Returns &lt;createTarget>.
   *
   * @param evt Current active native pointer event.
   */
  isCreateTarget(evt: Event) {
    return this.createTarget;
  }

  /**
   * Sets &lt;createTarget>.
   */
  setCreateTarget(value: boolean) {
    this.createTarget = value;
  }

  /**
   * Creates the preview shape for new connections.
   */
  createShape() {
    // Creates the edge preview
    const shape =
      this.livePreview &amp;&amp; this.edgeState
        ? this.graph.cellRenderer.createShape(this.edgeState)
        : new PolylineShape([], INVALID_COLOR);

    if (shape &amp;&amp; shape.node) {
      shape.dialect = DIALECT.SVG;
      shape.scale = this.graph.view.scale;
      shape.pointerEvents = false;
      shape.isDashed = true;
      shape.init(this.graph.getView().getOverlayPane());
      InternalEvent.redirectMouseEvents(shape.node, this.graph, null);
    }

    return shape;
  }

  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell: Cell) {
    return true;
  }

  /**
   * Creates and returns the &lt;mxCellMarker> used in &lt;marker>.
   */
  createMarker() {
    const self = this;

    class MyCellMarker extends CellMarker {
      hotspotEnabled = true;

      // Overrides to return cell at location only if valid (so that
      // there is no highlight for invalid cells)
      getCell(me: InternalMouseEvent) {
        let cell = super.getCell(me);
        self.error = null;

        // Checks for cell at preview point (with grid)
        if (!cell &amp;&amp; self.currentPoint) {
          cell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
        }

        // Uses connectable parent vertex if one exists
        if (cell &amp;&amp; !cell.isConnectable() &amp;&amp; self.cell) {
          const parent = self.cell.getParent();

          if (parent &amp;&amp; parent.isVertex() &amp;&amp; parent.isConnectable()) {
            cell = parent;
          }
        }

        if (cell) {
          if (
            (self.graph.isSwimlane(cell) &amp;&amp;
              self.currentPoint != null &amp;&amp;
              self.graph.hitsSwimlaneContent(
                cell,
                self.currentPoint.x,
                self.currentPoint.y
              )) ||
            !self.isConnectableCell(cell)
          ) {
            cell = null;
          }
        }

        if (cell) {
          if (self.isConnecting()) {
            if (self.previous) {
              self.error = self.validateConnection(self.previous.cell, cell);

              if (self.error &amp;&amp; self.error.length === 0) {
                cell = null;

                // Enables create target inside groups
                if (self.isCreateTarget(me.getEvent())) {
                  self.error = null;
                }
              }
            }
          } else if (!self.isValidSource(cell, me)) {
            cell = null;
          }
        } else if (
          self.isConnecting() &amp;&amp;
          !self.isCreateTarget(me.getEvent()) &amp;&amp;
          !self.graph.isAllowDanglingEdges()
        ) {
          self.error = '';
        }

        return cell;
      }

      // Sets the highlight color according to validateConnection
      isValidState(state: CellState) {
        if (self.isConnecting()) {
          return !self.error;
        }
        return super.isValidState(state);
      }

      // Overrides to use marker color only in highlight mode or for
      // target selection
      getMarkerColor(evt: Event, state: CellState, isValid: boolean) {
        return !self.connectImage || self.isConnecting()
          ? super.getMarkerColor(evt, state, isValid)
          : NONE;
      }

      // Overrides to use hotspot only for source selection otherwise
      // intersects always returns true when over a cell
      intersects(state: CellState, evt: InternalMouseEvent) {
        if (self.connectImage || self.isConnecting()) {
          return true;
        }
        return super.intersects(state, evt);
      }
    }

    return new MyCellMarker(this.graph) as CellMarker;
  }

  /**
   * Starts a new connection for the given state and coordinates.
   */
  start(state: CellState, x: number, y: number, edgeState: CellState) {
    console.log("ConnectionHandler start");
    this.previous = state;
    this.first = new Point(x, y);
    this.edgeState = edgeState ?? this.createEdgeState();

    // Marks the source state
    this.marker.currentColor = this.marker.validColor;
    this.marker.markedState = state;
    this.marker.mark();

    this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));
  }

  /**
   * Returns true if the source terminal has been clicked and a new
   * connection is currently being previewed.
   */
  isConnecting() {
    return !!this.first &amp;&amp; !!this.shape;
  }

  /**
   * Returns &lt;mxGraph.isValidSource> for the given source terminal.
   *
   * @param cell &lt;Cell> that represents the source terminal.
   * @param me &lt;mxMouseEvent> that is associated with this call.
   */
  isValidSource(cell: Cell, me: InternalMouseEvent) {
    return this.graph.isValidSource(cell);
  }

  /**
   * Returns true. The call to &lt;mxGraph.isValidTarget> is implicit by calling
   * &lt;mxGraph.getEdgeValidationError> in &lt;validateConnection>. This is an
   * additional hook for disabling certain targets in this specific handler.
   *
   * @param cell &lt;Cell> that represents the target terminal.
   */
  isValidTarget(cell: Cell) {
    return true;
  }

  /**
   * Returns the error message or an empty string if the connection for the
   * given source target pair is not valid. Otherwise it returns null. This
   * implementation uses &lt;mxGraph.getEdgeValidationError>.
   *
   * @param source &lt;Cell> that represents the source terminal.
   * @param target &lt;Cell> that represents the target terminal.
   */
  validateConnection(source: Cell, target: Cell) {
    if (!this.isValidTarget(target)) {
      return '';
    }
    return this.graph.getEdgeValidationError(null, source, target);
  }

  /**
   * Hook to return the &lt;mxImage> used for the connection icon of the given
   * &lt;CellState>. This implementation returns &lt;connectImage>.
   *
   * @param state &lt;CellState> whose connect image should be returned.
   */
  getConnectImage(state: CellState) {
    return this.connectImage;
  }

  /**
   * Returns true if the state has a HTML label in the graph's container, otherwise
   * it returns &lt;moveIconFront>.
   *
   * @param state &lt;CellState> whose connect icons should be returned.
   */
  isMoveIconToFrontForState(state: CellState) {
    if (state.text &amp;&amp; state.text.node.parentNode === this.graph.container) {
      return true;
    }
    return this.moveIconFront;
  }

  /**
   * Creates the array &lt;mxImageShapes> that represent the connect icons for
   * the given &lt;CellState>.
   *
   * @param state &lt;CellState> whose connect icons should be returned.
   */
  createIcons(state: CellState) {
    const image = this.getConnectImage(state);

    if (image) {
      this.iconState = state;
      const icons = [];

      // Cannot use HTML for the connect icons because the icon receives all
      // mouse move events in IE, must use VML and SVG instead even if the
      // connect-icon appears behind the selection border and the selection
      // border consumes the events before the icon gets a chance
      const bounds = new Rectangle(0, 0, image.width, image.height);
      const icon = new ImageShape(bounds, image.src, undefined, undefined, 0);
      icon.preserveImageAspect = false;

      if (this.isMoveIconToFrontForState(state)) {
        icon.dialect = DIALECT.STRICTHTML;
        icon.init(this.graph.container);
      } else {
        icon.dialect = DIALECT.SVG;
        icon.init(this.graph.getView().getOverlayPane());

        // Move the icon back in the overlay pane
        if (this.moveIconBack &amp;&amp; icon.node.parentNode &amp;&amp; icon.node.previousSibling) {
          icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);
        }
      }

      icon.node.style.cursor = CURSOR.CONNECT;

      // Events transparency
      const getState = () => {
        return this.currentState ?? state;
      };

      // Updates the local icon before firing the mouse down event.
      const mouseDown = (evt: MouseEvent) => {
        if (!isConsumed(evt)) {
          this.icon = icon;
          this.graph.fireMouseEvent(
            InternalEvent.MOUSE_DOWN,
            new InternalMouseEvent(evt, getState())
          );
        }
      };

      InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);

      icons.push(icon);
      this.redrawIcons(icons, this.iconState);

      return icons;
    }

    return [];
  }

  /**
   * Redraws the given array of &lt;mxImageShapes>.
   *
   * @param icons Array of &lt;mxImageShapes> to be redrawn.
   */
  redrawIcons(icons: ImageShape[], state: CellState) {
    if (icons[0] &amp;&amp; icons[0].bounds) {
      const pos = this.getIconPosition(icons[0], state);
      icons[0].bounds.x = pos.x;
      icons[0].bounds.y = pos.y;
      icons[0].redraw();
    }
  }

  // TODO: Document me! ===========================================================================================================
  getIconPosition(icon: ImageShape, state: CellState) {
    const { scale } = this.graph.getView();
    let cx = state.getCenterX();
    let cy = state.getCenterY();

    if (this.graph.isSwimlane(state.cell)) {
      const size = this.graph.getStartSize(state.cell);

      cx = size.width !== 0 ? state.x + (size.width * scale) / 2 : cx;
      cy = size.height !== 0 ? state.y + (size.height * scale) / 2 : cy;

      const alpha = toRadians(state.style.rotation ?? 0);

      if (alpha !== 0) {
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const ct = new Point(state.getCenterX(), state.getCenterY());
        const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);
        cx = pt.x;
        cy = pt.y;
      }
    }

    return new Point(cx - icon.bounds!.width / 2, cy - icon.bounds!.height / 2);
  }

  /**
   * Destroys the connect icons and resets the respective state.
   */
  destroyIcons() {
    for (let i = 0; i &lt; this.icons.length; i += 1) {
      this.icons[i].destroy();
    }

    this.icons = [];
    this.icon = null;
    this.selectedIcon = null;
    this.iconState = null;
  }

  /**
   * Returns true if the given mouse down event should start this handler. The
   * This implementation returns true if the event does not force marquee
   * selection, and the currentConstraint and currentFocus of the
   * &lt;constraintHandler> are not null, or &lt;previous> and &lt;error> are not null and
   * &lt;icons> is null or &lt;icons> and &lt;icon> are not null.
   */
  isStartEvent(me: InternalMouseEvent) {
    return (
      (this.constraintHandler.currentFocus !== null &amp;&amp;
        this.constraintHandler.currentConstraint !== null) ||
      (this.previous !== null &amp;&amp;
        this.error === null &amp;&amp;
        (this.icons.length === 0 || this.icon !== null))
    );
  }

  /**
   * Handles the event by initiating a new connection.
   */
  mouseDown(sender: EventSource, me: InternalMouseEvent) {
    this.mouseDownCounter += 1;

    if (
      this.isEnabled() &amp;&amp;
      this.graph.isEnabled() &amp;&amp;
      !me.isConsumed() &amp;&amp;
      !this.isConnecting() &amp;&amp;
      this.isStartEvent(me)
    ) {
      if (
        this.constraintHandler.currentConstraint &amp;&amp;
        this.constraintHandler.currentFocus &amp;&amp;
        this.constraintHandler.currentPoint
      ) {
        this.sourceConstraint = this.constraintHandler.currentConstraint;
        this.previous = this.constraintHandler.currentFocus;
        this.first = this.constraintHandler.currentPoint.clone();
      } else {
        // Stores the location of the initial mousedown
        this.first = new Point(me.getGraphX(), me.getGraphY());
      }

      this.edgeState = this.createEdgeState(me);
      this.mouseDownCounter = 1;

      if (this.waypointsEnabled &amp;&amp; !this.shape) {
        this.waypoints = [];
        this.shape = this.createShape();

        if (this.edgeState) {
          this.shape.apply(this.edgeState);
        }
      }

      // Stores the starting point in the geometry of the preview
      if (!this.previous &amp;&amp; this.edgeState &amp;&amp; this.edgeState.cell.geometry) {
        const pt = this.graph.getPointForEvent(me.getEvent());
        this.edgeState.cell.geometry.setTerminalPoint(pt, true);
      }

      this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));

      me.consume();
    }

    this.selectedIcon = this.icon;
    this.icon = null;
  }

  /**
   * Returns true if a tap on the given source state should immediately start
   * connecting. This implementation returns true if the state is not movable
   * in the graph.
   */
  isImmediateConnectSource(state: CellState) {
    return !this.graph.isCellMovable(state.cell);
  }

  /**
   * Hook to return an &lt;CellState> which may be used during the preview.
   * This implementation returns null.
   *
   * Use the following code to create a preview for an existing edge style:
   *
   * ```javascript
   * graph.connectionHandler.createEdgeState(me)
   * {
   *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');
   *
   *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));
   * };
   * ```
   */
  createEdgeState(me?: InternalMouseEvent): CellState | null {
    return null;
  }

  /**
   * Returns true if &lt;outlineConnect> is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me: InternalMouseEvent) {
    if (!this.currentPoint) return false;

    const offset = getOffset(this.graph.container);
    const evt = me.getEvent();

    const clientX = getClientX(evt);
    const clientY = getClientY(evt);

    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);

    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;

    return (
      this.outlineConnect &amp;&amp;
      !isShiftDown(me.getEvent()) &amp;&amp;
      (me.isSource(this.marker.highlight.shape) ||
        (isAltDown(me.getEvent()) &amp;&amp; me.getState() != null) ||
        this.marker.highlight.isHighlightAt(clientX, clientY) ||
        ((gridX !== clientX || gridY !== clientY) &amp;&amp;
          me.getState() == null &amp;&amp;
          this.marker.highlight.isHighlightAt(gridX, gridY)))
    );
  }

  /**
   * Updates the current state for a given mouse move event by using
   * the &lt;marker>.
   */
  updateCurrentState(me: InternalMouseEvent, point: Point): void {
    this.constraintHandler.update(
      me,
      !this.first,
      false,
      !this.first || me.isSource(this.marker.highlight.shape) ? null : point
    );

    if (
      this.constraintHandler.currentFocus != null &amp;&amp;
      this.constraintHandler.currentConstraint != null
    ) {
      // Handles special case where grid is large and connection point is at actual point in which
      // case the outline is not followed as long as we're &lt; gridSize / 2 away from that point
      if (
        this.marker.highlight &amp;&amp;
        this.marker.highlight.state &amp;&amp;
        this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell &amp;&amp;
        this.marker.highlight.shape
      ) {
        // Direct repaint needed if cell already highlighted
        if (this.marker.highlight.shape.stroke !== 'transparent') {
          this.marker.highlight.shape.stroke = 'transparent';
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');
      }

      // Updates validation state
      if (this.previous) {
        this.error = this.validateConnection(
          this.previous.cell,
          this.constraintHandler.currentFocus.cell
        );

        if (!this.error) {
          this.currentState = this.constraintHandler.currentFocus;
        }

        if (
          this.error ||
          (this.currentState &amp;&amp; !this.isCellEnabled(this.currentState.cell))
        ) {
          this.constraintHandler.reset();
        }
      }
    } else {
      if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
        this.marker.reset();
        this.currentState = null;
      } else {
        this.marker.process(me);
        this.currentState = this.marker.getValidState();
      }

      if (this.currentState != null &amp;&amp; !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
        this.currentState = null;
      }

      const outline = this.isOutlineConnectEvent(me);

      if (this.currentState != null &amp;&amp; outline) {
        // Handles special case where mouse is on outline away from actual end point
        // in which case the grid is ignored and mouse point is used instead
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point(me.getGraphX(), me.getGraphY());
        }

        const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
        this.constraintHandler.setFocus(me, this.currentState, false);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      }

      if (this.outlineConnect) {
        if (this.marker.highlight != null &amp;&amp; this.marker.highlight.shape != null) {
          const s = this.graph.view.scale;

          if (
            this.constraintHandler.currentConstraint != null &amp;&amp;
            this.constraintHandler.currentFocus != null
          ) {
            this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;
            this.marker.highlight.shape.strokeWidth =
              OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          } else if (this.marker.hasValidState()) {
            const cell = me.getCell();

            // Handles special case where actual end point of edge and current mouse point
            // are not equal (due to grid snapping) and there is no hit on shape or highlight
            // but ignores cases where parent is used for non-connectable child cells
            if (
              cell &amp;&amp;
              cell.isConnectable() &amp;&amp;
              this.marker.getValidState() !== me.getState()
            ) {
              this.marker.highlight.shape.stroke = 'transparent';
              this.currentState = null;
            } else {
              this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;
            }

            this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          }
        }
      }
    }
  }

  /**
   * Returns true if the given cell does not allow new connections to be created.
   */
  isCellEnabled(cell: Cell) {
    return true;
  }

  /**
   * Converts the given point from screen coordinates to model coordinates.
   */
  convertWaypoint(point: Point) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();

    point.x = point.x / scale - tr.x;
    point.y = point.y / scale - tr.y;
  }

  /**
   * Called to snap the given point to the current preview. This snaps to the
   * first point of the preview if alt is not pressed.
   */
  snapToPreview(me: InternalMouseEvent, point: Point) {
    if (!isAltDown(me.getEvent()) &amp;&amp; this.previous) {
      const tol = (this.graph.getGridSize() * this.graph.view.scale) / 2;
      const tmp =
        this.sourceConstraint &amp;&amp; this.first
          ? this.first
          : new Point(this.previous.getCenterX(), this.previous.getCenterY());

      if (Math.abs(tmp.x - me.getGraphX()) &lt; tol) {
        point.x = tmp.x;
      }

      if (Math.abs(tmp.y - me.getGraphY()) &lt; tol) {
        point.y = tmp.y;
      }
    }
  }

  /**
   * Handles the event by updating the preview edge or by highlighting
   * a possible source or target terminal.
   */
  mouseMove(sender: EventSource, me: InternalMouseEvent) {
    if (
      !me.isConsumed() &amp;&amp;
      (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)
    ) {
      // Handles special case when handler is disabled during highlight
      if (!this.isEnabled() &amp;&amp; this.currentState) {
        this.destroyIcons();
        this.currentState = null;
      }

      const view = this.graph.getView();
      const { scale } = view;
      const tr = view.translate;
      let point = new Point(me.getGraphX(), me.getGraphY());
      this.error = null;

      if (this.graph.isGridEnabledEvent(me.getEvent())) {
        point = new Point(
          (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale,
          (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale
        );
      }

      this.snapToPreview(me, point);
      this.currentPoint = point;

      if (
        (this.first || (this.isEnabled() &amp;&amp; this.graph.isEnabled())) &amp;&amp;
        (this.shape ||
          !this.first ||
          Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() ||
          Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())
      ) {
        this.updateCurrentState(me, point);
      }

      if (this.first) {
        let constraint = null;
        let current: Point | null = point;

        // Uses the current point from the constraint handler if available
        if (
          this.constraintHandler.currentConstraint &amp;&amp;
          this.constraintHandler.currentFocus &amp;&amp;
          this.constraintHandler.currentPoint
        ) {
          constraint = this.constraintHandler.currentConstraint;
          current = this.constraintHandler.currentPoint.clone();
        } else if (
          this.previous &amp;&amp;
          !this.graph.isIgnoreTerminalEvent(me.getEvent()) &amp;&amp;
          isShiftDown(me.getEvent())
        ) {
          if (
            Math.abs(this.previous.getCenterX() - point.x) &lt;
            Math.abs(this.previous.getCenterY() - point.y)
          ) {
            point.x = this.previous.getCenterX();
          } else {
            point.y = this.previous.getCenterY();
          }
        }

        let pt2: Point | null = this.first;

        // Moves the connect icon with the mouse
        if (this.selectedIcon &amp;&amp; this.selectedIcon.bounds) {
          const w = this.selectedIcon.bounds.width;
          const h = this.selectedIcon.bounds.height;

          if (this.currentState &amp;&amp; this.targetConnectImage) {
            const pos = this.getIconPosition(this.selectedIcon, this.currentState);
            this.selectedIcon.bounds.x = pos.x;
            this.selectedIcon.bounds.y = pos.y;
          } else {
            const bounds = new Rectangle(
              me.getGraphX() + this.connectIconOffset.x,
              me.getGraphY() + this.connectIconOffset.y,
              w,
              h
            );
            this.selectedIcon.bounds = bounds;
          }

          this.selectedIcon.redraw();
        }

        // Uses edge state to compute the terminal points
        if (this.edgeState) {
          this.updateEdgeState(current, constraint);
          current = this.edgeState.absolutePoints[
            this.edgeState.absolutePoints.length - 1
          ];
          pt2 = this.edgeState.absolutePoints[0];
        } else {
          if (this.currentState) {
            if (!this.constraintHandler.currentConstraint) {
              const tmp = this.getTargetPerimeterPoint(this.currentState, me);

              if (tmp != null) {
                current = tmp;
              }
            }
          }

          // Computes the source perimeter point
          if (!this.sourceConstraint &amp;&amp; this.previous) {
            const next = this.waypoints.length > 0 ? this.waypoints[0] : current;
            const tmp = this.getSourcePerimeterPoint(this.previous, next as Point, me);

            if (tmp) {
              pt2 = tmp;
            }
          }
        }

        // Makes sure the cell under the mousepointer can be detected
        // by moving the preview shape away from the mouse. This
        // makes sure the preview shape does not prevent the detection
        // of the cell under the mousepointer even for slow gestures.
        if (!this.currentState &amp;&amp; this.movePreviewAway &amp;&amp; current) {
          let tmp = pt2;

          if (this.edgeState &amp;&amp; this.edgeState.absolutePoints.length >= 2) {
            const tmp2 = this.edgeState.absolutePoints[
              this.edgeState.absolutePoints.length - 2
            ];

            if (tmp2) {
              tmp = tmp2;
            }
          }

          if (tmp) {
            const dx = current.x - tmp.x;
            const dy = current.y - tmp.y;

            const len = Math.sqrt(dx * dx + dy * dy);

            if (len === 0) {
              return;
            }

            // Stores old point to reuse when creating edge
            this.originalPoint = current.clone();
            current.x -= (dx * 4) / len;
            current.y -= (dy * 4) / len;
          }
        } else {
          this.originalPoint = null;
        }

        // Creates the preview shape (lazy)
        if (!this.shape) {
          const dx = Math.abs(me.getGraphX() - this.first.x);
          const dy = Math.abs(me.getGraphY() - this.first.y);

          if (
            dx > this.graph.getEventTolerance() ||
            dy > this.graph.getEventTolerance()
          ) {
            this.shape = this.createShape();

            if (this.edgeState) {
              this.shape.apply(this.edgeState);
            }

            // Revalidates current connection
            this.updateCurrentState(me, point);
          }
        }

        // Updates the points in the preview edge
        if (this.shape) {
          if (this.edgeState) {
            this.shape.points = this.edgeState.absolutePoints;
          } else {
            let pts = [pt2];

            if (this.waypoints.length > 0) {
              pts = pts.concat(this.waypoints);
            }

            pts.push(current);
            this.shape.points = pts;
          }

          this.drawPreview();
        }

        // Makes sure endpoint of edge is visible during connect
        if (this.cursor) {
          this.graph.container.style.cursor = this.cursor;
        }

        InternalEvent.consume(me.getEvent());
        me.consume();
      } else if (!this.isEnabled() || !this.graph.isEnabled()) {
        this.constraintHandler.reset();
      } else if (this.previous !== this.currentState &amp;&amp; !this.edgeState) {
        this.destroyIcons();

        // Sets the cursor on the current shape
        if (
          this.currentState &amp;&amp;
          !this.error &amp;&amp;
          !this.constraintHandler.currentConstraint
        ) {
          this.icons = this.createIcons(this.currentState);

          if (this.icons.length === 0) {
            this.currentState.setCursor(CURSOR.CONNECT);
            me.consume();
          }
        }

        this.previous = this.currentState;
      } else if (
        this.previous === this.currentState &amp;&amp;
        this.currentState != null &amp;&amp;
        this.icons.length === 0 &amp;&amp;
        !this.graph.isMouseDown
      ) {
        // Makes sure that no cursors are changed
        me.consume();
      }

      if (!this.graph.isMouseDown &amp;&amp; this.currentState != null &amp;&amp; this.icons != null) {
        let hitsIcon = false;
        const target = me.getSource();

        for (let i = 0; i &lt; this.icons.length &amp;&amp; !hitsIcon; i += 1) {
          hitsIcon =
            target === this.icons[i].node ||
            // @ts-ignore parentNode should exist.
            (!!target &amp;&amp; target.parentNode === this.icons[i].node);
        }

        if (!hitsIcon) {
          this.updateIcons(this.currentState, this.icons, me);
        }
      }
    } else {
      this.constraintHandler.reset();
    }
  }

  /**
   * Updates &lt;edgeState>.
   */
  updateEdgeState(current: Point | null, constraint: ConnectionConstraint | null) {
    if (!this.edgeState) return;

    // TODO: Use generic method for writing constraint to style
    if (this.sourceConstraint &amp;&amp; this.sourceConstraint.point) {
      this.edgeState.style.exitX = this.sourceConstraint.point.x;
      this.edgeState.style.exitY = this.sourceConstraint.point.y;
    }

    if (constraint &amp;&amp; constraint.point) {
      this.edgeState.style.entryX = constraint.point.x;
      this.edgeState.style.entryY = constraint.point.y;
    } else {
      this.edgeState.style.entryX = 0;
      this.edgeState.style.entryY = 0;
    }

    this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];

    if (this.sourceConstraint) {
      this.graph.view.updateFixedTerminalPoint(
        this.edgeState,
        this.previous,
        true,
        this.sourceConstraint
      );
    }

    if (this.currentState != null) {
      if (constraint == null) {
        constraint = this.graph.getConnectionConstraint(
          this.edgeState,
          this.previous,
          false
        );
      }

      this.edgeState.setAbsoluteTerminalPoint(null, false);
      this.graph.view.updateFixedTerminalPoint(
        this.edgeState,
        this.currentState,
        false,
        constraint
      );
    }

    // Scales and translates the waypoints to the model
    let realPoints = [];

    for (let i = 0; i &lt; this.waypoints.length; i += 1) {
      const pt = this.waypoints[i].clone();
      this.convertWaypoint(pt);
      realPoints[i] = pt;
    }

    this.graph.view.updatePoints(
      this.edgeState,
      realPoints,
      this.previous,
      this.currentState
    );
    this.graph.view.updateFloatingTerminalPoints(
      this.edgeState,
      this.previous,
      this.currentState
    );
  }

  /**
   * Returns the perimeter point for the given target state.
   *
   * @param state &lt;CellState> that represents the target cell state.
   * @param me &lt;mxMouseEvent> that represents the mouse move.
   */
  getTargetPerimeterPoint(state: CellState, me: InternalMouseEvent) {
    let result: Point | null = null;
    const { view } = state;
    const targetPerimeter = view.getPerimeterFunction(state);

    if (targetPerimeter &amp;&amp; this.previous) {
      const next =
        this.waypoints.length > 0
          ? this.waypoints[this.waypoints.length - 1]
          : new Point(this.previous.getCenterX(), this.previous.getCenterY());
      const tmp = targetPerimeter(
        view.getPerimeterBounds(state),
        this.edgeState,
        next,
        false
      );

      if (tmp) {
        result = tmp;
      }
    } else {
      result = new Point(state.getCenterX(), state.getCenterY());
    }

    return result;
  }

  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state &lt;CellState> that represents the target cell state.
   * @param next &lt;mxPoint> that represents the next point along the previewed edge.
   * @param me &lt;mxMouseEvent> that represents the mouse move.
   */
  getSourcePerimeterPoint(state: CellState, next: Point, me: InternalMouseEvent) {
    let result = null;
    const { view } = state;
    const sourcePerimeter = view.getPerimeterFunction(state);
    const c = new Point(state.getCenterX(), state.getCenterY());

    if (sourcePerimeter) {
      const theta = state.style.rotation ?? 0;
      const rad = -theta * (Math.PI / 180);

      if (theta !== 0) {
        next = getRotatedPoint(
          new Point(next.x, next.y),
          Math.cos(rad),
          Math.sin(rad),
          c
        );
      }

      let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);

      if (tmp) {
        if (theta !== 0) {
          tmp = getRotatedPoint(
            new Point(tmp.x, tmp.y),
            Math.cos(-rad),
            Math.sin(-rad),
            c
          );
        }

        result = tmp;
      }
    } else {
      result = c;
    }

    return result;
  }

  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state &lt;CellState> under the mouse.
   * @param icons Array of currently displayed icons.
   * @param me &lt;mxMouseEvent> that contains the mouse event.
   */
  updateIcons(state: CellState, icons: ImageShape[], me: InternalMouseEvent) {
    // empty
  }

  /**
   * Returns true if the given mouse up event should stop this handler. The
   * connection will be created if &lt;error> is null. Note that this is only
   * called if &lt;waypointsEnabled> is true. This implemtation returns true
   * if there is a cell state in the given event.
   */
  isStopEvent(me: InternalMouseEvent) {
    return !!me.getState();
  }

  /**
   * Adds the waypoint for the given event to &lt;waypoints>.
   */
  addWaypointForEvent(me: InternalMouseEvent) {
    if (!this.first) return;

    let point = convertPoint(this.graph.container, me.getX(), me.getY());
    const dx = Math.abs(point.x - this.first.x);
    const dy = Math.abs(point.y - this.first.y);
    const addPoint =
      this.waypoints.length > 0 ||
      (this.mouseDownCounter > 1 &amp;&amp;
        (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()));

    if (addPoint) {
      const { scale } = this.graph.view;
      point = new Point(
        this.graph.snap(me.getGraphX() / scale) * scale,
        this.graph.snap(me.getGraphY() / scale) * scale
      );
      this.waypoints.push(point);
    }
  }

  /**
   * Returns true if the connection for the given constraints is valid. This
   * implementation returns true if the constraints are not pointing to the
   * same fixed connection point.
   */
  checkConstraints(c1: ConnectionConstraint | null, c2: ConnectionConstraint | null) {
    return (
      !c1 ||
      !c2 ||
      !c1.point ||
      !c2.point ||
      !c1.point.equals(c2.point) ||
      c1.dx !== c2.dx ||
      c1.dy !== c2.dy ||
      c1.perimeter !== c2.perimeter
    );
  }

  /**
   * Handles the event by inserting the new connection.
   */
  mouseUp(sender: EventSource, me: InternalMouseEvent) {
    if (!me.isConsumed() &amp;&amp; this.isConnecting()) {
      if (this.waypointsEnabled &amp;&amp; !this.isStopEvent(me)) {
        this.addWaypointForEvent(me);
        me.consume();

        return;
      }

      const c1 = this.sourceConstraint;
      const c2 = this.constraintHandler.currentConstraint;

      const source = this.previous ? this.previous.cell : null;
      let target = null;

      if (
        this.constraintHandler.currentConstraint &amp;&amp;
        this.constraintHandler.currentFocus
      ) {
        target = this.constraintHandler.currentFocus.cell;
      }

      if (!target &amp;&amp; this.currentState) {
        target = this.currentState.cell;
      }

      // Inserts the edge if no validation error exists and if constraints differ
      if (
        !this.error &amp;&amp;
        (!source || !target || source !== target || this.checkConstraints(c1, c2))
      ) {
        this.connect(source, target, me.getEvent(), me.getCell());
      } else {
        // Selects the source terminal for self-references
        if (
          this.previous != null &amp;&amp;
          this.marker.validState != null &amp;&amp;
          this.previous.cell === this.marker.validState.cell
        ) {
          this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());
        }

        // Displays the error message if it is not an empty string,
        // for empty error messages, the event is silently dropped
        if (this.error != null &amp;&amp; this.error.length > 0) {
          this.graph.validationAlert(this.error);
        }
      }

      // Redraws the connect icons and resets the handler state
      this.destroyIcons();
      me.consume();
    }

    if (this.first != null) {
      this.reset();
    }
  }

  /**
   * Resets the state of this handler.
   */
  reset(): void {
    if (this.shape != null) {
      this.shape.destroy();
      this.shape = null;
    }

    // Resets the cursor on the container
    if (this.cursor != null &amp;&amp; this.graph.container != null) {
      this.graph.container.style.cursor = '';
    }

    this.destroyIcons();
    this.marker.reset();
    this.constraintHandler.reset();
    this.originalPoint = null;
    this.currentPoint = null;
    this.edgeState = null;
    this.previous = null;
    this.error = null;
    this.sourceConstraint = null;
    this.mouseDownCounter = 0;
    this.first = null;

    this.fireEvent(new EventObject(InternalEvent.RESET));
  }

  /**
   * Redraws the preview edge using the color and width returned by
   * &lt;getEdgeColor> and &lt;getEdgeWidth>.
   */
  drawPreview() {
    this.updatePreview(this.error === null);
    if (this.shape) this.shape.redraw();
  }

  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  updatePreview(valid: boolean) {
    if (this.shape) {
      this.shape.strokeWidth = this.getEdgeWidth(valid);
      this.shape.stroke = this.getEdgeColor(valid);
    }
  }

  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  getEdgeColor(valid: boolean) {
    return valid ? VALID_COLOR : INVALID_COLOR;
  }

  /**
   * Returns the width used to draw the preview edge. This returns 3 if
   * there is no edge validation error and 1 otherwise.
   *
   * @param valid Boolean indicating if the width for a valid edge should be
   * returned.
   */
  getEdgeWidth(valid: boolean): number {
    return valid ? 3 : 1;
  }

  /**
   * Connects the given source and target using a new edge. This
   * implementation uses &lt;createEdge> to create the edge.
   *
   * @param source &lt;Cell> that represents the source terminal.
   * @param target &lt;Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget &lt;Cell> that represents the cell under the mouse when it was
   * released.
   */
  connect(
    source: Cell | null,
    target: Cell | null,
    evt: MouseEvent,
    dropTarget: Cell | null = null
  ) {
    if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {
      // Uses the common parent of source and target or
      // the default parent to insert the edge
      const model = this.graph.getModel();
      let terminalInserted = false;
      let edge: Cell | null = null;

      model.beginUpdate();
      try {
        if (
          source &amp;&amp;
          !target &amp;&amp;
          !this.graph.isIgnoreTerminalEvent(evt) &amp;&amp;
          this.isCreateTarget(evt)
        ) {
          target = this.createTargetVertex(evt, source);

          if (target) {
            dropTarget = this.graph.getDropTarget(new CellArray(target), evt, dropTarget);
            terminalInserted = true;

            // Disables edges as drop targets if the target cell was created
            // FIXME: Should not shift if vertex was aligned (same in Java)
            if (dropTarget == null || !dropTarget.isEdge()) {
              const pstate = dropTarget
                ? this.graph.getView().getState(dropTarget)
                : null;

              if (pstate) {
                const tmp = target.getGeometry();

                if (tmp) {
                  tmp.x -= pstate.origin.x;
                  tmp.y -= pstate.origin.y;
                }
              }
            } else {
              dropTarget = this.graph.getDefaultParent();
            }

            this.graph.addCell(target, dropTarget);
          }
        }

        let parent: Cell | null = this.graph.getDefaultParent();

        if (
          source &amp;&amp;
          target &amp;&amp;
          source.getParent() === target.getParent() &amp;&amp;
          source.getParent()?.getParent() !== model.getRoot()
        ) {
          parent = source.getParent();

          if (
            source.geometry &amp;&amp;
            source.geometry.relative &amp;&amp;
            target.geometry &amp;&amp;
            target.geometry.relative
          ) {
            parent = parent!.getParent();
          }
        }

        // Uses the value of the preview edge state for inserting
        // the new edge into the graph
        let value = null;
        let style = '';

        if (this.edgeState) {
          value = this.edgeState.cell.value;
          style = this.edgeState.cell.style ?? '';
        }

        edge = this.insertEdge(parent as Cell, '', value, source, target, style);

        if (edge &amp;&amp; source) {
          // Updates the connection constraints
          this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);
          this.graph.setConnectionConstraint(
            edge,
            target,
            false,
            this.constraintHandler.currentConstraint
          );

          // Uses geometry of the preview edge state
          if (this.edgeState &amp;&amp; this.edgeState.cell &amp;&amp; this.edgeState.cell.geometry) {
            model.setGeometry(edge, this.edgeState.cell.geometry);
          }

          parent = source.getParent();

          // Inserts edge before source
          if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {
            const index = null;
            let tmp: Cell | null = source;

            while (
              tmp &amp;&amp;
              tmp.parent != null &amp;&amp;
              tmp.geometry != null &amp;&amp;
              tmp.geometry.relative &amp;&amp;
              tmp.parent !== edge.parent
            ) {
              tmp = tmp.getParent();
            }

            if (tmp != null &amp;&amp; tmp.parent != null &amp;&amp; tmp.parent === edge.parent) {
              model.add(parent, edge, tmp.parent.getIndex(tmp));
            }
          }

          // Makes sure the edge has a non-null, relative geometry
          let geo = edge.getGeometry();

          if (geo == null) {
            geo = new Geometry();
            geo.relative = true;

            model.setGeometry(edge, geo);
          }

          // Uses scaled waypoints in geometry
          if (this.waypoints.length > 0) {
            const s = this.graph.view.scale;
            const tr = this.graph.view.translate;
            geo.points = [];

            for (let i = 0; i &lt; this.waypoints.length; i += 1) {
              const pt = this.waypoints[i];
              geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));
            }
          }

          if (!target &amp;&amp; this.currentPoint) {
            const t = this.graph.view.translate;
            const s = this.graph.view.scale;
            const pt =
              this.originalPoint != null
                ? new Point(
                    this.originalPoint.x / s - t.x,
                    this.originalPoint.y / s - t.y
                  )
                : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;
            geo.setTerminalPoint(pt, false);
          }

          this.fireEvent(
            new EventObject(
              InternalEvent.CONNECT,
              'cell',
              edge,
              'terminal',
              target,
              'event',
              evt,
              'target',
              dropTarget,
              'terminalInserted',
              terminalInserted
            )
          );
        }
      } catch (e) {
        MaxLog.show();
        // MaxLog.debug(e.message);
      } finally {
        model.endUpdate();
      }

      if (this.select) {
        this.selectCells(edge, terminalInserted ? target : null);
      }
    }
  }

  /**
   * Selects the given edge after adding a new connection. The target argument
   * contains the target vertex if one has been inserted.
   */
  selectCells(edge: Cell | null, target: Cell | null) {
    this.graph.setSelectionCell(edge);
  }

  /**
   * Creates, inserts and returns the new edge for the given parameters. This
   * implementation does only use &lt;createEdge> if &lt;factoryMethod> is defined,
   * otherwise &lt;mxGraph.insertEdge> will be used.
   */
  insertEdge(
    parent: Cell,
    id: string,
    value: any,
    source: Cell | null,
    target: Cell | null,
    style: string
  ): Cell {
    if (!this.factoryMethod) {
      return this.graph.insertEdge(parent, id, value, source, target, style);
    }
    let edge = this.createEdge(value, source, target, style);
    edge = this.graph.addEdge(edge, parent, source, target);

    return edge;
  }

  /**
   * Hook method for creating new vertices on the fly if no target was
   * under the mouse. This is only called if &lt;createTarget> is true and
   * returns null.
   *
   * @param evt Mousedown event of the connect gesture.
   * @param source &lt;Cell> that represents the source terminal.
   */
  createTargetVertex(evt: MouseEvent, source: Cell) {
    // Uses the first non-relative source
    let geo = source.getGeometry();

    while (geo &amp;&amp; geo.relative) {
      source = source.getParent() as Cell;
      geo = source.getGeometry();
    }

    const clone = this.graph.cloneCell(source);
    geo = clone.getGeometry();

    if (geo &amp;&amp; this.currentPoint) {
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      const point = new Point(
        this.currentPoint.x / s - t.x,
        this.currentPoint.y / s - t.y
      );
      geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);
      geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);

      // Aligns with source if within certain tolerance
      const tol = this.getAlignmentTolerance();

      if (tol > 0) {
        const sourceState = this.graph.view.getState(source);

        if (sourceState != null) {
          const x = sourceState.x / s - t.x;
          const y = sourceState.y / s - t.y;

          if (Math.abs(x - geo.x) &lt;= tol) {
            geo.x = Math.round(x);
          }

          if (Math.abs(y - geo.y) &lt;= tol) {
            geo.y = Math.round(y);
          }
        }
      }
    }

    return clone;
  }

  /**
   * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.
   */
  getAlignmentTolerance(evt?: MouseEvent): number {
    return this.graph.isGridEnabled()
      ? this.graph.getGridSize() / 2
      : this.graph.getSnapTolerance();
  }

  /**
   * Creates and returns a new edge using &lt;factoryMethod> if one exists. If
   * no factory method is defined, then a new default edge is returned. The
   * source and target arguments are informal, the actual connection is
   * setup later by the caller of this function.
   *
   * @param value Value to be used for creating the edge.
   * @param source &lt;Cell> that represents the source terminal.
   * @param target &lt;Cell> that represents the target terminal.
   * @param style Optional style from the preview edge.
   */
  createEdge(value: any, source: Cell | null, target: Cell | null, style: string = '') {
    let edge = null;

    // Creates a new edge using the factoryMethod
    if (this.factoryMethod != null) {
      edge = this.factoryMethod(source, target, style);
    }

    if (edge == null) {
      edge = new Cell(value || '');
      edge.setEdge(true);
      edge.setStyle(style);

      const geo = new Geometry();
      geo.relative = true;
      edge.setGeometry(geo);
    }

    return edge;
  }

  /**
   * Destroys the handler and all its resources and DOM nodes. This should be
   * called on all instances. It is called automatically for the built-in
   * instance created for each &lt;mxGraph>.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);

    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }

    if (this.marker) {
      this.marker.destroy();
      // @ts-expect-error this.marker is null when it is destroyed.
      this.marker = null;
    }

    if (this.constraintHandler) {
      this.constraintHandler.onDestroy();
    }

    if (this.changeHandler) {
      this.graph.getModel().removeListener(this.changeHandler);
      this.graph.getView().removeListener(this.changeHandler);
    }

    if (this.drillHandler) {
      this.graph.removeListener(this.drillHandler);
      this.graph.getView().removeListener(this.drillHandler);
    }

    if (this.escapeHandler) {
      this.graph.removeListener(this.escapeHandler);
    }
  }
}

export default ConnectionHandler;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
