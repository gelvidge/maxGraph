

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/layout/hierarchical/CoordinateAssignment.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/layout/hierarchical/CoordinateAssignment.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2018, JGraph Ltd
 * Copyright (c) 2006-2018, Gaudenz Alder
 * Updated to ES9 syntax by David Morrissey 2021
 * Type definitions from the typed-mxgraph project
 */
import HierarchicalLayoutStage from './HierarchicalLayoutStage';
import { DIRECTION } from '../../../util/constants';
import MaxLog from '../../../gui/MaxLog';
import WeightedCellSorter from '../util/WeightedCellSorter';
import Dictionary from '../../../util/Dictionary';
import Point from '../../geometry/Point';
import HierarchicalEdgeStyle from '../datatypes/HierarchicalEdgeStyle';
import HierarchicalLayout from '../HierarchicalLayout';
import GraphHierarchyModel from './GraphHierarchyModel';
import Cell from '../../../view/cell/Cell';
import GraphHierarchyNode from '../datatypes/GraphHierarchyNode';
import GraphAbstractHierarchyCell from '../datatypes/GraphAbstractHierarchyCell';
import { _mxCompactTreeLayoutNode } from '../CompactTreeLayout';
import { Graph } from '../../../view/Graph';
import Geometry from '../../../view/geometry/Geometry';
import GraphHierarchyEdge from '../datatypes/GraphHierarchyEdge';
import SwimlaneLayout from '../SwimlaneLayout';

/**
 * Sets the horizontal locations of node and edge dummy nodes on each layer.
 * Uses median down and up weighings as well as heuristics to straighten edges as
 * far as possible.
 *
 * Constructor: mxCoordinateAssignment
 *
 * Creates a coordinate assignment.
 *
 * Arguments:
 *
 * intraCellSpacing - the minimum buffer between cells on the same rank
 * interRankCellSpacing - the minimum distance between cells on adjacent ranks
 * orientation - the position of the root node(s) relative to the graph
 * initialX - the leftmost coordinate node placement starts at
 */
class CoordinateAssignment extends HierarchicalLayoutStage {
  constructor(
    layout: HierarchicalLayout | SwimlaneLayout,
    intraCellSpacing: number=30,
    interRankCellSpacing: number=100,
    orientation: DIRECTION,
    initialX: number,
    parallelEdgeSpacing: number=10
  ) {
    super();

    this.layout = layout;
    this.intraCellSpacing = intraCellSpacing;
    this.interRankCellSpacing = interRankCellSpacing;
    this.orientation = orientation;
    this.initialX = initialX;
    this.parallelEdgeSpacing = parallelEdgeSpacing;
  }

  /**
   * Reference to the enclosing &lt;HierarchicalLayout>.
   */
  layout: HierarchicalLayout | SwimlaneLayout;

  /**
   * The minimum buffer between cells on the same rank. Default is 30.
   */
  intraCellSpacing = 30;

  /**
   * The minimum distance between cells on adjacent ranks. Default is 100.
   */
  interRankCellSpacing = 100;

  /**
   * The distance between each parallel edge on each ranks for long edges.
   * Default is 10.
   */
  parallelEdgeSpacing = 10;

  /**
   * The number of heuristic iterations to run. Default is 8.
   */
  maxIterations = 8;

  /**
   * The preferred horizontal distance between edges exiting a vertex Default is 5.
   */
  prefHozEdgeSep = 5;

  /**
   * The preferred vertical offset between edges exiting a vertex Default is 2.
   */
  prefVertEdgeOff = 2;

  /**
   * The minimum distance for an edge jetty from a vertex Default is 12.
   */
  minEdgeJetty = 12;

  /**
   * The size of the vertical buffer in the center of inter-rank channels
   * where edge control points should not be placed Default is 4.
   */
  channelBuffer = 4;

  /**
   * Map of internal edges and (x,y) pair of positions of the start and end jetty
   * for that edge where it connects to the source and target vertices.
   * Note this should technically be a WeakHashMap, but since JS does not
   * have an equivalent, housekeeping must be performed before using.
   * i.e. check all edges are still in the model and clear the values.
   * Note that the y co-ord is the offset of the jetty, not the
   * absolute point
   */
  jettyPositions: { [key: string]: number[] } | null = null;

  /**
   * The position of the root ( start ) node(s) relative to the rest of the
   * laid out graph. Default is &lt;mxConstants.DIRECTION.NORTH>.
   */
  orientation: DIRECTION = DIRECTION.NORTH;

  /**
   * The minimum x position node placement starts at
   */
  initialX: number;

  /**
   * The maximum x value this positioning lays up to
   */
  limitX: number | null = null;

  /**
   * The sum of x-displacements for the current iteration
   */
  currentXDelta: number | null = null;

  /**
   * The rank that has the widest x position
   */
  widestRank: number | null = null;

  /**
   * Internal cache of top-most values of Y for each rank
   */
  rankTopY: number[] | null = null;

  /**
   * Internal cache of bottom-most value of Y for each rank
   */
  rankBottomY: number[] | null = null;

  /**
   * The X-coordinate of the edge of the widest rank
   */
  widestRankValue: number | null = null;

  /**
   * The width of all the ranks
   */
  rankWidths: number[] | null = null;

  /**
   * The Y-coordinate of all the ranks
   */
  rankY: number[] | null = null;

  /**
   * Whether or not to perform local optimisations and iterate multiple times
   * through the algorithm. Default is true.
   */
  fineTuning = true;

  /**
   * A store of connections to the layer above for speed
   */
  nextLayerConnectedCache = null;

  /**
   * A store of connections to the layer below for speed
   */
  previousLayerConnectedCache = null;

  /**
   * Padding added to resized parents Default is 10.
   */
  groupPadding = 10;

  /**
   * Utility method to display current positions
   */
  printStatus() {
    const model = &lt;GraphHierarchyModel>this.layout.getModel();
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;
    
    MaxLog.show();
    MaxLog.writeln('======Coord assignment debug=======');

    for (let j = 0; j &lt; ranks.length; j++) {
      MaxLog.write('Rank ', String(j), ' : ');
      const rank = ranks[j];

      for (let k = 0; k &lt; rank.length; k++) {
        const cell = rank[k];
        MaxLog.write(String(cell.getGeneralPurposeVariable(j)), '  ');
      }
      MaxLog.writeln();
    }
    MaxLog.writeln('====================================');
  }

  /**
   * A basic horizontal coordinate assignment algorithm
   */
  execute(parent: any) {
    this.jettyPositions = Object();
    const model = &lt;GraphHierarchyModel>this.layout.getModel();
    this.currentXDelta = 0.0;

    this.initialCoords(this.layout.getGraph(), model);

    //  this.printStatus();

    if (this.fineTuning) {
      this.minNode(model);
    }

    let bestXDelta = 100000000.0;

    if (this.fineTuning) {
      for (let i = 0; i &lt; this.maxIterations; i += 1) {
        //      this.printStatus();

        // Median Heuristic
        if (i !== 0) {
          this.medianPos(i, model);
          this.minNode(model);
        }

        // if the total offset is less for the current positioning,
        // there are less heavily angled edges and so the current
        // positioning is used
        const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;

        if (this.currentXDelta &lt; bestXDelta) {
          for (let j = 0; j &lt; ranks.length; j++) {
            const rank = ranks[j];

            for (let k = 0; k &lt; rank.length; k++) {
              const cell = rank[k];
              cell.setX(j, &lt;number>cell.getGeneralPurposeVariable(j));
            }
          }

          bestXDelta = this.currentXDelta;
        } else {
          // Restore the best positions
          for (let j = 0; j &lt; ranks.length; j++) {
            const rank = ranks[j];

            for (let k = 0; k &lt; rank.length; k++) {
              const cell = rank[k];
              cell.setGeneralPurposeVariable(j, cell.getX(j));
            }
          }
        }

        this.minPath(this.layout.getGraph(), model);
        this.currentXDelta = 0;
      }
    }
    this.setCellLocations(this.layout.getGraph(), model);
  }

  /**
   * Performs one median positioning sweep in both directions
   */
  minNode(model: GraphHierarchyModel) {
    // Queue all nodes
    const nodeList: WeightedCellSorter[] = [];

    // Need to be able to map from cell to cellWrapper
    const map: Dictionary&lt;GraphAbstractHierarchyCell, WeightedCellSorter> = new Dictionary();
    const rank = [];

    for (let i = 0; i &lt;= model.maxRank; i += 1) {
      rank[i] = (&lt;GraphAbstractHierarchyCell[][]>model.ranks)[i];

      for (let j = 0; j &lt; rank[i].length; j += 1) {
        // Use the weight to store the rank and visited to store whether
        // or not the cell is in the list
        const node = rank[i][j];
        const nodeWrapper = new WeightedCellSorter(node, i);
        nodeWrapper.rankIndex = j;
        nodeWrapper.visited = true;
        nodeList.push(nodeWrapper);

        map.put(node, nodeWrapper);
      }
    }

    // Set a limit of the maximum number of times we will access the queue
    // in case a loop appears
    const maxTries = nodeList.length * 10;
    let count = 0;

    // Don't move cell within this value of their median
    const tolerance = 1;

    while (nodeList.length > 0 &amp;&amp; count &lt;= maxTries) {
      const cellWrapper = &lt;WeightedCellSorter>nodeList.shift();
      const cell: GraphAbstractHierarchyCell = cellWrapper.cell;

      const rankValue = cellWrapper.weightedValue;
      const rankIndex = parseInt(String(cellWrapper.rankIndex));

      const nextLayerConnectedCells = &lt;GraphAbstractHierarchyCell[]>cell.getNextLayerConnectedCells(rankValue);
      const previousLayerConnectedCells = &lt;GraphAbstractHierarchyCell[]>cell.getPreviousLayerConnectedCells(rankValue);

      const numNextLayerConnected = nextLayerConnectedCells.length;
      const numPreviousLayerConnected = previousLayerConnectedCells.length;

      const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);
      const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);

      const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
      const currentPosition = &lt;number>cell.getGeneralPurposeVariable(rankValue);
      let cellMedian = &lt;number>currentPosition;

      if (numConnectedNeighbours > 0) {
        cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
      }

      // Flag storing whether or not position has changed
      let positionChanged = false;

      if (cellMedian &lt; currentPosition - tolerance) {
        if (rankIndex === 0) {
          cell.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const leftCell = rank[rankValue][rankIndex - 1];
          let leftLimit = &lt;number>leftCell.getGeneralPurposeVariable(rankValue);
          leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;

          if (leftLimit &lt; cellMedian) {
            cell.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (leftLimit &lt; &lt;number>cell.getGeneralPurposeVariable(rankValue) - tolerance) {
            cell.setGeneralPurposeVariable(rankValue, leftLimit);
            positionChanged = true;
          }
        }
      } else if (cellMedian > currentPosition + tolerance) {
        const rankSize = rank[rankValue].length;

        if (rankIndex === rankSize - 1) {
          cell.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const rightCell = rank[rankValue][rankIndex + 1];
          let rightLimit = &lt;number>rightCell.getGeneralPurposeVariable(rankValue);
          rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;

          if (rightLimit > cellMedian) {
            cell.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (rightLimit > &lt;number>cell.getGeneralPurposeVariable(rankValue) + tolerance) {
            cell.setGeneralPurposeVariable(rankValue, rightLimit);
            positionChanged = true;
          }
        }
      }

      if (positionChanged) {
        // Add connected nodes to map and list
        for (let i = 0; i &lt; nextLayerConnectedCells.length; i += 1) {
          const connectedCell: GraphAbstractHierarchyCell = nextLayerConnectedCells[i];
          const connectedCellWrapper = map.get(connectedCell);

          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }

        // Add connected nodes to map and list
        for (let i = 0; i &lt; previousLayerConnectedCells.length; i += 1) {
          const connectedCell = previousLayerConnectedCells[i];
          const connectedCellWrapper = map.get(connectedCell);

          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }
      }

      cellWrapper.visited = false;
      count += 1;
    }
  }

  /**
   * Performs one median positioning sweep in one direction
   *
   * @param i the iteration of the whole process
   * @param model an internal model of the hierarchical layout
   */
  medianPos(i: number, model: GraphHierarchyModel) {
    // Reverse sweep direction each time through this method
    const downwardSweep = i % 2 === 0;

    if (downwardSweep) {
      for (let j = model.maxRank; j > 0; j--) {
        this.rankMedianPosition(j - 1, model, j);
      }
    } else {
      for (let j = 0; j &lt; model.maxRank - 1; j++) {
        this.rankMedianPosition(j + 1, model, j);
      }
    }
  }

  /**
   * Performs median minimisation over one rank.
   *
   * @param rankValue the layer number of this rank
   * @param model an internal model of the hierarchical layout
   * @param nextRankValue the layer number whose connected cels are to be laid out
   * relative to
   */
  rankMedianPosition(
    rankValue: number, 
    model: GraphHierarchyModel, 
    nextRankValue: number
  ) {
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;
    const rank = ranks[rankValue];

    // Form an array of the order in which the cell are to be processed
    // , the order is given by the weighted sum of the in or out edges,
    // depending on whether we're traveling up or down the hierarchy.
    const weightedValues = [];
    const cellMap: { [key: string]: WeightedCellSorter } = {};

    for (let i = 0; i &lt; rank.length; i += 1) {
      const currentCell = rank[i];
      weightedValues[i] = new WeightedCellSorter();
      weightedValues[i].cell = currentCell;
      weightedValues[i].rankIndex = i;
      cellMap[&lt;string>currentCell.id] = weightedValues[i];
      let nextLayerConnectedCells = null;

      if (nextRankValue &lt; rankValue) {
        nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);
      } else {
        nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);
      }

      // Calculate the weighing based on this node type and those this
      // node is connected to on the next layer
      weightedValues[i].weightedValue = this.calculatedWeightedValue(
        currentCell, &lt;GraphAbstractHierarchyCell[]>nextLayerConnectedCells
      );
    }
    weightedValues.sort(WeightedCellSorter.compare);

    // Set the new position of each node within the rank using
    // its temp variable

    for (let i = 0; i &lt; weightedValues.length; i += 1) {
      let numConnectionsNextLevel = 0;
      const { cell } = weightedValues[i];
      let nextLayerConnectedCells = null;
      let medianNextLevel = 0;

      if (nextRankValue &lt; rankValue) {
        nextLayerConnectedCells = cell
          .getPreviousLayerConnectedCells(rankValue)
          .slice();
      } else {
        nextLayerConnectedCells = cell
          .getNextLayerConnectedCells(rankValue)
          .slice();
      }

      if (nextLayerConnectedCells != null) {
        numConnectionsNextLevel = nextLayerConnectedCells.length;

        if (numConnectionsNextLevel > 0) {
          medianNextLevel = this.medianXValue(
            nextLayerConnectedCells,
            nextRankValue
          );
        } else {
          // For case of no connections on the next level set the
          // median to be the current position and try to be
          // positioned there
          medianNextLevel = cell.getGeneralPurposeVariable(rankValue);
        }
      }

      let leftBuffer = 0.0;
      let leftLimit = -100000000.0;

      for (let j = &lt;number>weightedValues[i].rankIndex - 1; j >= 0; ) {
        const weightedValue = cellMap[&lt;string>rank[j].id];

        if (weightedValue != null) {
          const leftCell = weightedValue.cell;

          if (weightedValue.visited) {
            // The left limit is the right hand limit of that
            // cell plus any allowance for unallocated cells
            // in-between
            leftLimit =
              leftCell.getGeneralPurposeVariable(rankValue) +
              leftCell.width / 2.0 +
              this.intraCellSpacing +
              leftBuffer +
              cell.width / 2.0;
            j = -1;
          } else {
            leftBuffer += leftCell.width + this.intraCellSpacing;
            j--;
          }
        }
      }

      let rightBuffer = 0.0;
      let rightLimit = 100000000.0;

      for (
        let j = &lt;number>weightedValues[i].rankIndex + 1;
        j &lt; weightedValues.length;

      ) {
        const weightedValue = cellMap[&lt;string>rank[j].id];

        if (weightedValue != null) {
          const rightCell = weightedValue.cell;

          if (weightedValue.visited) {
            // The left limit is the right hand limit of that
            // cell plus any allowance for unallocated cells
            // in-between
            rightLimit =
              rightCell.getGeneralPurposeVariable(rankValue) -
              rightCell.width / 2.0 -
              this.intraCellSpacing -
              rightBuffer -
              cell.width / 2.0;
            j = weightedValues.length;
          } else {
            rightBuffer += rightCell.width + this.intraCellSpacing;
            j++;
          }
        }
      }

      if (medianNextLevel >= leftLimit &amp;&amp; medianNextLevel &lt;= rightLimit) {
        cell.setGeneralPurposeVariable(rankValue, medianNextLevel);
      } else if (medianNextLevel &lt; leftLimit) {
        // Couldn't place at median value, place as close to that
        // value as possible
        cell.setGeneralPurposeVariable(rankValue, leftLimit);
        this.currentXDelta = &lt;number>this.currentXDelta + leftLimit - medianNextLevel;
      } else if (medianNextLevel > rightLimit) {
        // Couldn't place at median value, place as close to that
        // value as possible
        cell.setGeneralPurposeVariable(rankValue, rightLimit);
        this.currentXDelta = &lt;number>this.currentXDelta + medianNextLevel - rightLimit;
      }

      weightedValues[i].visited = true;
    }
  }

  /**
   * Calculates the priority the specified cell has based on the type of its
   * cell and the cells it is connected to on the next layer
   *
   * @param currentCell the cell whose weight is to be calculated
   * @param collection the cells the specified cell is connected to
   */
  calculatedWeightedValue(currentCell: Cell, collection: GraphAbstractHierarchyCell[]) {
    let totalWeight = 0;

    for (let i = 0; i &lt; collection.length; i += 1) {
      const cell = collection[i];

      if (currentCell.isVertex() &amp;&amp; cell.isVertex()) {
        totalWeight += 1;
      } else if (currentCell.isEdge() &amp;&amp; cell.isEdge()) {
        totalWeight += 8;
      } else {
        totalWeight += 2;
      }
    }
    return totalWeight;
  }

  /**
   * Calculates the median position of the connected cell on the specified
   * rank
   *
   * @param connectedCells the cells the candidate connects to on this level
   * @param rankValue the layer number of this rank
   */
  medianXValue(connectedCells: GraphAbstractHierarchyCell[], rankValue: number) {
    if (connectedCells.length === 0) {
      return 0;
    }

    const medianValues = [];
    for (let i = 0; i &lt; connectedCells.length; i += 1) {
      medianValues[i] = &lt;number>connectedCells[i].getGeneralPurposeVariable(rankValue);
    }
    medianValues.sort((a: number, b: number) => a - b);

    if (connectedCells.length % 2 === 1) {
      // For odd numbers of adjacent vertices return the median
      return medianValues[Math.floor(connectedCells.length / 2)];
    }
    const medianPoint = connectedCells.length / 2;
    const leftMedian = medianValues[medianPoint - 1];
    const rightMedian = medianValues[medianPoint];
    return (leftMedian + rightMedian) / 2;
  }

  /**
   * Sets up the layout in an initial positioning. The ranks are all centered
   * as much as possible along the middle vertex in each rank. The other cells
   * are then placed as close as possible on either side.
   *
   * @param facade the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  initialCoords(facade: Graph, model: GraphHierarchyModel) {
    this.calculateWidestRank(facade, model);

    // Sweep up and down from the widest rank
    for (let i = &lt;number>this.widestRank; i >= 0; i--) {
      if (i &lt; model.maxRank) {
        this.rankCoordinates(i, facade, model);
      }
    }

    for (let i = &lt;number>this.widestRank + 1; i &lt;= model.maxRank; i += 1) {
      if (i > 0) {
        this.rankCoordinates(i, facade, model);
      }
    }
  }

  /**
   * Sets up the layout in an initial positioning. All the first cells in each
   * rank are moved to the left and the rest of the rank inserted as close
   * together as their size and buffering permits. This method works on just
   * the specified rank.
   *
   * @param rankValue the current rank being processed
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  rankCoordinates(rankValue: number, graph: Graph, model: GraphHierarchyModel) {
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;
    const rank = ranks[rankValue];
    let maxY = 0.0;
    let localX =
      this.initialX + (&lt;number>this.widestRankValue - (&lt;number[]>this.rankWidths)[rankValue]) / 2;

    // Store whether or not any of the cells' bounds were unavailable so
    // to only issue the warning once for all cells
    let boundsWarning = false;

    for (let i = 0; i &lt; rank.length; i += 1) {
      const node = rank[i];

      if (node.isVertex()) {
        const bounds = this.layout.getVertexBounds((&lt;GraphHierarchyNode>node).cell);

        if (bounds != null) {
          if (
            this.orientation === DIRECTION.NORTH ||
            this.orientation === DIRECTION.SOUTH
          ) {
            node.width = bounds.width;
            node.height = bounds.height;
          } else {
            node.width = bounds.height;
            node.height = bounds.width;
          }
        } else {
          boundsWarning = true;
        }

        maxY = Math.max(maxY, node.height);
      } else if (node.isEdge()) {
        // The width is the number of additional parallel edges
        // time the parallel edge spacing
        let numEdges = 1;

        if (node.edges != null) {
          numEdges = node.edges.length;
        } else {
          MaxLog.warn('edge.edges is null');
        }

        node.width = (numEdges - 1) * this.parallelEdgeSpacing;
      }

      // Set the initial x-value as being the best result so far
      localX += node.width / 2.0;
      node.setX(rankValue, localX);
      node.setGeneralPurposeVariable(rankValue, localX);
      localX += node.width / 2.0;
      localX += this.intraCellSpacing;
    }

    if (boundsWarning == true) {
      MaxLog.warn('At least one cell has no bounds');
    }
  }

  /**
   * Calculates the width rank in the hierarchy. Also set the y value of each
   * rank whilst performing the calculation
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  calculateWidestRank(graph: Graph, model: GraphHierarchyModel) {
    // Starting y co-ordinate
    let y = -this.interRankCellSpacing;

    // Track the widest cell on the last rank since the y
    // difference depends on it
    let lastRankMaxCellHeight = 0.0;
    this.rankWidths = [];
    this.rankY = [];

    for (let rankValue = model.maxRank; rankValue >= 0; rankValue -= 1) {
      // Keep track of the widest cell on this rank
      let maxCellHeight = 0.0;
      const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;
      const rank = ranks[rankValue];
      let localX = this.initialX;

      // Store whether or not any of the cells' bounds were unavailable so
      // to only issue the warning once for all cells
      let boundsWarning = false;

      for (let i = 0; i &lt; rank.length; i += 1) {
        const node = rank[i];

        if (node.isVertex()) {
          const bounds = this.layout.getVertexBounds((&lt;GraphHierarchyNode>node).cell);

          if (bounds != null) {
            if (
              this.orientation === DIRECTION.NORTH ||
              this.orientation === DIRECTION.SOUTH
            ) {
              node.width = bounds.width;
              node.height = bounds.height;
            } else {
              node.width = bounds.height;
              node.height = bounds.width;
            }
          } else {
            boundsWarning = true;
          }

          maxCellHeight = Math.max(maxCellHeight, node.height);
        } else if (node.isEdge()) {
          // The width is the number of additional parallel edges
          // time the parallel edge spacing
          let numEdges = 1;

          if (node.edges != null) {
            numEdges = node.edges.length;
          } else {
            MaxLog.warn('edge.edges is null');
          }

          node.width = (numEdges - 1) * this.parallelEdgeSpacing;
        }

        // Set the initial x-value as being the best result so far
        localX += node.width / 2.0;
        node.setX(rankValue, localX);
        node.setGeneralPurposeVariable(rankValue, localX);
        localX += node.width / 2.0;
        localX += this.intraCellSpacing;

        if (localX > &lt;number>this.widestRankValue) {
          this.widestRankValue = localX;
          this.widestRank = rankValue;
        }

        this.rankWidths[rankValue] = localX;
      }

      if (boundsWarning == true) {
        MaxLog.warn('At least one cell has no bounds');
      }

      this.rankY[rankValue] = y;
      const distanceToNextRank =
        maxCellHeight / 2.0 +
        lastRankMaxCellHeight / 2.0 +
        this.interRankCellSpacing;
      lastRankMaxCellHeight = maxCellHeight;

      if (
        this.orientation === DIRECTION.NORTH ||
        this.orientation === DIRECTION.WEST
      ) {
        y += distanceToNextRank;
      } else {
        y -= distanceToNextRank;
      }

      for (let i = 0; i &lt; rank.length; i += 1) {
        const cell = rank[i];
        cell.setY(rankValue, y);
      }
    }
  }

  /**
   * Straightens out chains of virtual nodes where possibleacade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  minPath(graph: Graph, model: GraphHierarchyModel) {
    // Work down and up each edge with at least 2 control points
    // trying to straighten each one out. If the same number of
    // straight segments are formed in both directions, the
    // preferred direction used is the one where the final
    // control points have the least offset from the connectable
    // region of the terminating vertices
    const edges = model.edgeMapper.getValues();

    for (let j = 0; j &lt; edges.length; j++) {
      const cell = edges[j];

      if (cell.maxRank - cell.minRank - 1 &lt; 1) {
        continue;
      }

      // At least two virtual nodes in the edge
      // Check first whether the edge is already straight
      let referenceX = cell.getGeneralPurposeVariable(cell.minRank + 1);
      let edgeStraight = true;
      let refSegCount = 0;

      for (let i = cell.minRank + 2; i &lt; cell.maxRank; i += 1) {
        const x = cell.getGeneralPurposeVariable(i);

        if (referenceX !== x) {
          edgeStraight = false;
          referenceX = x;
        } else {
          refSegCount += 1;
        }
      }

      if (!edgeStraight) {
        let upSegCount = 0;
        let downSegCount = 0;
        const upXPositions = [];
        const downXPositions = [];
        let i = 0;

        let currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);

        for (i = cell.minRank + 1; i &lt; cell.maxRank - 1; i += 1) {
          // Attempt to straight out the control point on the
          // next segment up with the current control point.
          const nextX = cell.getX(i + 1);

          if (currentX === nextX) {
            upXPositions[i - cell.minRank - 1] = currentX;
            upSegCount += 1;
          } else if (this.repositionValid(model, cell, i + 1, currentX)) {
            upXPositions[i - cell.minRank - 1] = currentX;
            upSegCount += 1;
            // Leave currentX at same value
          } else {
            upXPositions[i - cell.minRank - 1] = nextX;
            currentX = nextX;
          }
        }

        currentX = cell.getX(i);

        for (let i = cell.maxRank - 1; i > cell.minRank + 1; i--) {
          // Attempt to straight out the control point on the
          // next segment down with the current control point.
          const nextX = cell.getX(i - 1);

          if (currentX === nextX) {
            downXPositions[i - cell.minRank - 2] = currentX;
            downSegCount += 1;
          } else if (this.repositionValid(model, cell, i - 1, currentX)) {
            downXPositions[i - cell.minRank - 2] = currentX;
            downSegCount += 1;
            // Leave currentX at same value
          } else {
            downXPositions[i - cell.minRank - 2] = cell.getX(i - 1);
            currentX = nextX;
          }
        }

        if (downSegCount > refSegCount || upSegCount > refSegCount) {
          if (downSegCount >= upSegCount) {
            // Apply down calculation values
            for (let i = cell.maxRank - 2; i > cell.minRank; i--) {
              cell.setX(i, downXPositions[i - cell.minRank - 1]);
            }
          } else if (upSegCount > downSegCount) {
            // Apply up calculation values
            for (let i = cell.minRank + 2; i &lt; cell.maxRank; i += 1) {
              cell.setX(i, upXPositions[i - cell.minRank - 2]);
            }
          } else {
            // Neither direction provided a favourable result
            // But both calculations are better than the
            // existing solution, so apply the one with minimal
            // offset to attached vertices at either end.
          }
        }
      }
    }
  }

  /**
   * Determines whether or not a node may be moved to the specified x
   * position on the specified rank
   *
   * @param model the layout model
   * @param cell the cell being analysed
   * @param rank the layer of the cell
   * @param position the x position being sought
   */
  repositionValid(model: GraphHierarchyModel, cell: GraphHierarchyEdge | GraphHierarchyNode, rank: number, position: number) {
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;
    const rankArray = ranks[rank];
    let rankIndex = -1;

    for (let i = 0; i &lt; rankArray.length; i += 1) {
      if (cell === rankArray[i]) {
        rankIndex = i;
        break;
      }
    }

    if (rankIndex &lt; 0) {
      return false;
    }

    const currentX = cell.getGeneralPurposeVariable(rank);

    if (position &lt; currentX) {
      // Trying to move node to the left.
      if (rankIndex === 0) {
        // Left-most node, can move anywhere
        return true;
      }

      const leftCell = rankArray[rankIndex - 1];
      let leftLimit = &lt;number>leftCell.getGeneralPurposeVariable(rank);
      leftLimit =
        leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;

      return leftLimit &lt;= position;
    }
    if (position > currentX) {
      // Trying to move node to the right.
      if (rankIndex === rankArray.length - 1) {
        // Right-most node, can move anywhere
        return true;
      }

      const rightCell = rankArray[rankIndex + 1];
      let rightLimit = &lt;number>rightCell.getGeneralPurposeVariable(rank);
      rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;
      return rightLimit >= position;
    }
    return true;
  }

  /**
   * Sets the cell locations in the facade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the input graph
   * @param model the layout model
   */
  setCellLocations(graph: Graph, model: GraphHierarchyModel) {
    this.rankTopY = [];
    this.rankBottomY = [];
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;

    for (let i = 0; i &lt; ranks.length; i += 1) {
      this.rankTopY[i] = Number.MAX_VALUE;
      this.rankBottomY[i] = -Number.MAX_VALUE;
    }

    const vertices = model.vertexMapper.getValues();

    // Process vertices all first, since they define the lower and
    // limits of each rank. Between these limits lie the channels
    // where the edges can be routed across the graph

    for (let i = 0; i &lt; vertices.length; i += 1) {
      this.setVertexLocation(vertices[i]);
    }

    // Post process edge styles. Needs the vertex locations set for initial
    // values of the top and bottoms of each rank
    if (
      this.layout.edgeStyle === HierarchicalEdgeStyle.ORTHOGONAL ||
      this.layout.edgeStyle === HierarchicalEdgeStyle.POLYLINE ||
      this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE
    ) {
      this.localEdgeProcessing(model);
    }

    const edges = model.edgeMapper.getValues();
    for (let i = 0; i &lt; edges.length; i += 1) {
      this.setEdgePosition(edges[i]);
    }
  }

  /**
   * Separates the x position of edges as they connect to vertices
   *
   * @param model the layout model
   */
  localEdgeProcessing(model: GraphHierarchyModel) {
    // Iterate through each vertex, look at the edges connected in
    // both directions.
    const ranks = &lt;GraphAbstractHierarchyCell[][]>model.ranks;

    for (let rankIndex = 0; rankIndex &lt; ranks.length; rankIndex += 1) {
      const rank = ranks[rankIndex];

      for (let cellIndex = 0; cellIndex &lt; rank.length; cellIndex += 1) {
        const cell = rank[cellIndex];

        if (cell.isVertex()) {
          let currentCells = cell.getPreviousLayerConnectedCells(rankIndex);

          let currentRank = rankIndex - 1;

          // Two loops, last connected cells, and next
          for (let k = 0; k &lt; 2; k += 1) {
            if (
              currentRank > -1 &amp;&amp;
              currentRank &lt; ranks.length &amp;&amp;
              currentCells != null &amp;&amp;
              currentCells.length > 0
            ) {
              const sortedCells = [];

              for (let j = 0; j &lt; currentCells.length; j++) {
                const sorter = new WeightedCellSorter(
                  currentCells[j],
                  currentCells[j].getX(currentRank)
                );
                sortedCells.push(sorter);
              }

              sortedCells.sort(WeightedCellSorter.compare);

              let leftLimit = cell.x[0] - cell.width / 2;
              let rightLimit = leftLimit + cell.width;

              // Connected edge count starts at 1 to allow for buffer
              // with edge of vertex
              let connectedEdgeCount = 0;
              let connectedEdgeGroupCount = 0;
              const connectedEdges = [];
              // Calculate width requirements for all connected edges
              for (let j = 0; j &lt; sortedCells.length; j++) {
                const innerCell = sortedCells[j].cell;
                var connections;

                if (innerCell.isVertex()) {
                  // Get the connecting edge
                  if (k === 0) {
                    connections = (&lt;GraphHierarchyNode>cell).connectsAsSource;
                  } else {
                    connections = (&lt;GraphHierarchyNode>cell).connectsAsTarget;
                  }

                  for (
                    let connIndex = 0;
                    connIndex &lt; connections.length;
                    connIndex += 1
                  ) {
                    if (
                      connections[connIndex].source === innerCell ||
                      connections[connIndex].target === innerCell
                    ) {
                      connectedEdgeCount += connections[connIndex].edges.length;
                      connectedEdgeGroupCount += 1;

                      connectedEdges.push(connections[connIndex]);
                    }
                  }
                } else {
                  connectedEdgeCount += innerCell.edges.length;
                  connectedEdgeGroupCount += 1;
                  connectedEdges.push(innerCell);
                }
              }

              const requiredWidth =
                (connectedEdgeCount + 1) * this.prefHozEdgeSep;

              // Add a buffer on the edges of the vertex if the edge count allows
              if (cell.width > requiredWidth + 2 * this.prefHozEdgeSep) {
                leftLimit += this.prefHozEdgeSep;
                rightLimit -= this.prefHozEdgeSep;
              }

              const availableWidth = rightLimit - leftLimit;
              const edgeSpacing = availableWidth / connectedEdgeCount;

              let currentX = leftLimit + edgeSpacing / 2.0;
              let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
              let maxYOffset = 0;

              for (let j = 0; j &lt; connectedEdges.length; j++) {
                const numActualEdges = connectedEdges[j].edges.length;
                const jettyPositions = &lt;{ [key: string]: number[] }>this.jettyPositions;
                let pos = jettyPositions[connectedEdges[j].ids[0]];

                if (pos == null) {
                  pos = [];
                  jettyPositions[connectedEdges[j].ids[0]] = pos;
                }

                if (j &lt; connectedEdgeCount / 2) {
                  currentYOffset += this.prefVertEdgeOff;
                } else if (j > connectedEdgeCount / 2) {
                  currentYOffset -= this.prefVertEdgeOff;
                }
                // Ignore the case if equals, this means the second of 2
                // jettys with the same y (even number of edges)

                for (let m = 0; m &lt; numActualEdges; m += 1) {
                  pos[m * 4 + k * 2] = currentX;
                  currentX += edgeSpacing;
                  pos[m * 4 + k * 2 + 1] = currentYOffset;
                }

                maxYOffset = Math.max(maxYOffset, currentYOffset);
              }
            }

            currentCells = cell.getNextLayerConnectedCells(rankIndex);
            currentRank = rankIndex + 1;
          }
        }
      }
    }
  }

  /**
   * Fixes the control points
   */
  setEdgePosition(cell: GraphHierarchyEdge) {
    // For parallel edges we need to seperate out the points a
    // little
    let offsetX = 0;
    // Only set the edge control points once

    if (cell.temp[0] !== 101207) {
      let { maxRank } = cell;
      let { minRank } = cell;

      if (maxRank === minRank) {
        maxRank = (&lt;GraphHierarchyNode>cell.source).maxRank;
        minRank = (&lt;GraphHierarchyNode>cell.target).minRank;
      }

      let parallelEdgeCount = 0;
      const jettyPositions = &lt;{ [key: string]: number[] }>this.jettyPositions;
      const jettys = jettyPositions[cell.ids[0]];

      const source = cell.isReversed ? (&lt;GraphHierarchyNode>cell.target).cell : (&lt;GraphHierarchyNode>cell.source).cell;
      const { graph } = this.layout;
      const layoutReversed =
        this.orientation === DIRECTION.EAST ||
        this.orientation === DIRECTION.SOUTH;

      for (let i = 0; i &lt; cell.edges.length; i += 1) {
        const realEdge = cell.edges[i];
        const realSource = this.layout.getVisibleTerminal(realEdge, true);

        // List oldPoints = graph.getPoints(realEdge);
        const newPoints = [];

        // Single length reversed edges end up with the jettys in the wrong
        // places. Since single length edges only have jettys, not segment
        // control points, we just say the edge isn't reversed in this section
        let reversed = cell.isReversed;

        if (realSource !== source) {
          // The real edges include all core model edges and these can go
          // in both directions. If the source of the hierarchical model edge
          // isn't the source of the specific real edge in this iteration
          // treat if as reversed
          reversed = !reversed;
        }

        // First jetty of edge
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankBottomY = &lt;number[]>this.rankBottomY;
          const rankTopY = &lt;number[]>this.rankTopY;

          let y = reversed
            ? layoutReversed
              ? rankBottomY[minRank]
              : rankTopY[minRank]
            : layoutReversed
            ? rankTopY[maxRank]
            : rankBottomY[maxRank];
          let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];

          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }

          y += jetty;
          let x = jettys[parallelEdgeCount * 4 + arrayOffset];

          const modelSource = &lt;Cell>realEdge.getTerminal(true);

          if (this.layout.isPort(modelSource) &amp;&amp; modelSource.getParent() === realSource) {
            const state = graph.view.getState(modelSource);

            if (state != null) {
              x = state.x;
            } else {
              x = (&lt;Geometry>(&lt;Cell>realSource).geometry).x + (&lt;GraphHierarchyNode>cell.source).width * (&lt;Geometry>modelSource.geometry).x;
            }
          }

          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            newPoints.push(new Point(x, y));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(x, y + jetty));
            }

          } else {
            newPoints.push(new Point(y, x));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(y + jetty, x));
            }
          }
        }

        // Declare variables to define loop through edge points and
        // change direction if edge is reversed

        let loopStart = cell.x.length - 1;
        let loopLimit = -1;
        let loopDelta = -1;
        let currentRank = cell.maxRank - 1;

        if (reversed) {
          loopStart = 0;
          loopLimit = cell.x.length;
          loopDelta = 1;
          currentRank = cell.minRank + 1;
        }
        // Reversed edges need the points inserted in
        // reverse order
        for (
          let j = loopStart;
          cell.maxRank !== cell.minRank &amp;&amp; j !== loopLimit;
          j += loopDelta
        ) {
          // The horizontal position in a vertical layout
          const positionX = cell.x[j] + offsetX;

          // Work out the vertical positions in a vertical layout
          // in the edge buffer channels above and below this rank
          const rankTopY = &lt;number[]>this.rankTopY;
          const rankBottomY = &lt;number[]>this.rankBottomY;

          let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2.0;
          let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2.0;

          if (reversed) {
            const tmp = topChannelY;
            topChannelY = bottomChannelY;
            bottomChannelY = tmp;
          }

          if (
            this.orientation === DIRECTION.NORTH ||
            this.orientation === DIRECTION.SOUTH
          ) {
            newPoints.push(new Point(positionX, topChannelY));
            newPoints.push(new Point(positionX, bottomChannelY));
          } else {
            newPoints.push(new Point(topChannelY, positionX));
            newPoints.push(new Point(bottomChannelY, positionX));
          }

          this.limitX = Math.max(&lt;number>this.limitX, positionX);
          currentRank += loopDelta;
        }

        // Second jetty of edge
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankTopY = &lt;number[]>this.rankTopY;
          const rankBottomY = &lt;number[]>this.rankBottomY;

          const rankY = reversed
            ? layoutReversed
              ? rankTopY[maxRank]
              : rankBottomY[maxRank]
            : layoutReversed
            ? rankBottomY[minRank]
            : rankTopY[minRank];
          let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];

          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }
          const y = rankY - jetty;
          let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];

          const modelTarget = &lt;Cell>realEdge.getTerminal(false);
          const realTarget = &lt;Cell>this.layout.getVisibleTerminal(realEdge, false);

          if (
            this.layout.isPort(modelTarget) &amp;&amp;
            modelTarget.getParent() === realTarget
          ) {
            const state = graph.view.getState(modelTarget);
            if (state != null) {
              x = state.x;
            } else {
              x =
                (&lt;Geometry>realTarget.geometry).x +
                (&lt;GraphHierarchyNode>cell.target).width * (&lt;Geometry>modelTarget.geometry).x;
            }
          }

          if (
            this.orientation === DIRECTION.NORTH ||
            this.orientation === DIRECTION.SOUTH
          ) {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(x, y - jetty));
            }
            newPoints.push(new Point(x, y));

          } else {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {
              newPoints.push(new Point(y - jetty, x));
            }
            newPoints.push(new Point(y, x));
          }
        }

        if (cell.isReversed) {
          this.processReversedEdge(cell, realEdge);
        }

        this.layout.setEdgePoints(realEdge, newPoints);

        // Increase offset so next edge is drawn next to
        // this one
        if (offsetX === 0.0) {
          offsetX = this.parallelEdgeSpacing;
        } else if (offsetX > 0) {
          offsetX = -offsetX;
        } else {
          offsetX = -offsetX + this.parallelEdgeSpacing;
        }

        parallelEdgeCount++;
      }
      cell.temp[0] = 101207;
    }
  }

  /**
   * Fixes the position of the specified vertex.
   *
   * @param cell the vertex to position
   */
  setVertexLocation(cell: GraphHierarchyNode) {
    const realCell = cell.cell;
    const positionX = cell.x[0] - cell.width / 2;
    const positionY = cell.y[0] - cell.height / 2;
    const rankTopY = &lt;number[]>this.rankTopY;
    const rankBottomY = &lt;number[]>this.rankBottomY;

    rankTopY[cell.minRank] = Math.min(rankTopY[cell.minRank], positionY);
    rankBottomY[cell.minRank] = Math.max(rankBottomY[cell.minRank], positionY + cell.height);

    if (
      this.orientation === DIRECTION.NORTH ||
      this.orientation === DIRECTION.SOUTH
    ) {
      this.layout.setVertexLocation(realCell, positionX, positionY);
    } else {
      this.layout.setVertexLocation(realCell, positionY, positionX);
    }
    this.limitX = Math.max(&lt;number>this.limitX, positionX + cell.width);
  }

  /**
   * Hook to add additional processing
   *
   * @param edge the hierarchical model edge
   * @param realEdge the real edge in the graph
   */
  processReversedEdge(edge: GraphHierarchyEdge, realEdge: Cell) {
    // hook for subclassers
  }
}

export default CoordinateAssignment;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
